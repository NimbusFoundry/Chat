// Generated by CoffeeScript 1.8.0
(function() {
  var $, Auth, Binary, Class, Client, DB, DelayedOp, DelayedSyncAnimation, Dropbox, DropboxClient, DropboxOauth, DropboxXhr, DropboxXhrCanSendForms, DropboxXhrIeMode, DropboxXhrRequest, Events, Model, Nimbus, OneOp, REALTIME_MIMETYPE, Set, Share, add32, arrayToBase64, atob, atobNibble, base64Digits, base64HmacSha1, base64Sha1, baseUrl, btoa, btoaNibble, crypto, dropboxEncodeKey, exports, handleErrors, headID, hmacSha1, isArray, makeArray, mixpanel_token, moduleKeywords, newScript, realTimeEvents, rotateLeft32, sha1, stringToArray, _base64Digits,
    __hasProp = {}.hasOwnProperty,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (window.Nimbus == null) {
    window.Nimbus = {};
  }

  Nimbus = window.Nimbus;

  Nimbus.realtime = {};

  Nimbus.realtime.handle_initialization = null;

  Nimbus.loaded = false;

  window.handleClientLoad = function() {
    console.log("loaded CALLED");
    Nimbus.loaded = true;
    Nimbus.gapi_loaded = false;
    Nimbus.gapi_loaded_callback = function() {
      return console.log('the orginal gapi callback');
    };
    gapi.load("auth:client,drive-realtime,drive-share", function() {
      log("gapi for everything loaded");
      Nimbus.gapi_loaded = true;
      return Nimbus.gapi_loaded_callback();
    });
    if (Nimbus.gdrive_initialized) {
      return Nimbus.Auth.initialize();
    }
  };

  headID = document.getElementsByTagName("head")[0];

  newScript = document.createElement("script");

  newScript.type = "text/javascript";

  newScript.src = "https://apis.google.com/js/client.js?onload=handleClientLoad";

  headID.appendChild(newScript);

  Dropbox = (function() {
    function Dropbox(options) {
      this.client = new DropboxClient(options);
    }

    return Dropbox;

  })();

  Dropbox.ApiError = (function() {
    function ApiError(xhr, method, url) {
      var e, text;
      this.method = method;
      this.url = url;
      this.status = xhr.status;
      if (xhr.responseType) {
        text = xhr.response || xhr.responseText;
      } else {
        text = xhr.responseText;
      }
      if (text) {
        try {
          this.responseText = text.toString();
          this.response = JSON.parse(text);
        } catch (_error) {
          e = _error;
          this.response = null;
        }
      } else {
        this.responseText = '(no response)';
        this.response = null;
      }
    }

    ApiError.prototype.toString = function() {
      return "Dropbox API error " + this.status + " from " + this.method + " " + this.url + " :: " + this.responseText;
    };

    ApiError.prototype.inspect = function() {
      return this.toString();
    };

    return ApiError;

  })();

  if (typeof window !== "undefined" && window !== null) {
    if (window.atob && window.btoa) {
      atob = function(string) {
        return window.atob(string);
      };
      btoa = function(base64) {
        return window.btoa(base64);
      };
    } else {
      base64Digits = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      btoaNibble = function(accumulator, bytes, result) {
        var i, limit;
        limit = 3 - bytes;
        accumulator <<= limit * 8;
        i = 3;
        while (i >= limit) {
          result.push(base64Digits.charAt((accumulator >> (i * 6)) & 0x3F));
          i -= 1;
        }
        i = bytes;
        while (i < 3) {
          result.push('=');
          i += 1;
        }
        return null;
      };
      atobNibble = function(accumulator, digits, result) {
        var i, limit;
        limit = 4 - digits;
        accumulator <<= limit * 6;
        i = 2;
        while (i >= limit) {
          result.push(String.fromCharCode((accumulator >> (8 * i)) & 0xFF));
          i -= 1;
        }
        return null;
      };
      btoa = function(string) {
        var accumulator, bytes, i, result, _i, _ref;
        result = [];
        accumulator = 0;
        bytes = 0;
        for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          accumulator = (accumulator << 8) | string.charCodeAt(i);
          bytes += 1;
          if (bytes === 3) {
            btoaNibble(accumulator, bytes, result);
            accumulator = bytes = 0;
          }
        }
        if (bytes > 0) {
          btoaNibble(accumulator, bytes, result);
        }
        return result.join('');
      };
      atob = function(base64) {
        var accumulator, digit, digits, i, result, _i, _ref;
        result = [];
        accumulator = 0;
        digits = 0;
        for (i = _i = 0, _ref = base64.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          digit = base64.charAt(i);
          if (digit === '=') {
            break;
          }
          accumulator = (accumulator << 6) | base64Digits.indexOf(digit);
          digits += 1;
          if (digits === 4) {
            atobNibble(accumulator, digits, result);
            accumulator = digits = 0;
          }
        }
        if (digits > 0) {
          atobNibble(accumulator, digits, result);
        }
        return result.join('');
      };
    }
  } else {
    atob = function(arg) {
      var buffer, i;
      buffer = new Buffer(arg, 'base64');
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = buffer.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(String.fromCharCode(buffer[i]));
        }
        return _results;
      })()).join('');
    };
    btoa = function(arg) {
      var buffer, i;
      buffer = new Buffer((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = arg.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(arg.charCodeAt(i));
        }
        return _results;
      })());
      return buffer.toString('base64');
    };
  }

  Dropbox.Client = (function() {
    function Client(options) {
      this.sandbox = options.sandbox || false;
      this.apiServer = options.server || this.defaultApiServer();
      this.authServer = options.authServer || this.defaultAuthServer();
      this.fileServer = options.fileServer || this.defaultFileServer();
      this.oauth = new DropboxOauth(options);
      this.uid = null;
      this.authState = null;
      this.authError = null;
      this._credentials = null;
      this.setCredentials(options);
      this.setupUrls();
    }

    Client.prototype.authDriver = function(driver) {
      this.driver = driver;
      return this;
    };

    Client.prototype.dropboxUid = function() {
      return this.uid;
    };

    Client.prototype.credentials = function() {
      if (!this._credentials) {
        this.computeCredentials();
      }
      return this._credentials;
    };

    Client.prototype.authenticate = function(callback) {
      var oldAuthState, _fsmStep;
      oldAuthState = null;
      _fsmStep = (function(_this) {
        return function() {
          var authUrl;
          if (oldAuthState !== _this.authState) {
            oldAuthState = _this.authState;
            if (_this.driver.onAuthStateChange) {
              return _this.driver.onAuthStateChange(_this, _fsmStep);
            }
          }
          switch (_this.authState) {
            case DropboxClient.RESET:
              return _this.requestToken(function(error, data) {
                var token, tokenSecret;
                if (error) {
                  _this.authError = error;
                  _this.authState = DropboxClient.ERROR;
                } else {
                  token = data.oauth_token;
                  tokenSecret = data.oauth_token_secret;
                  _this.oauth.setToken(token, tokenSecret);
                  _this.authState = DropboxClient.REQUEST;
                }
                _this._credentials = null;
                return _fsmStep();
              });
            case DropboxClient.REQUEST:
              authUrl = _this.authorizeUrl(_this.oauth.token);
              return _this.driver.doAuthorize(authUrl, _this.oauth.token, _this.oauth.tokenSecret, function() {
                _this.authState = DropboxClient.AUTHORIZED;
                _this._credentials = null;
                return _fsmStep();
              });
            case DropboxClient.AUTHORIZED:
              return _this.getAccessToken(function(error, data) {
                if (error) {
                  _this.authError = error;
                  _this.authState = DropboxClient.ERROR;
                } else {
                  _this.oauth.setToken(data.oauth_token, data.oauth_token_secret);
                  _this.uid = data.uid;
                  _this.authState = DropboxClient.DONE;
                }
                _this._credentials = null;
                return _fsmStep();
              });
            case DropboxClient.DONE:
              return callback(null, _this);
            case Dropbox.SIGNED_OFF:
              _this.reset();
              return _fsmStep();
            case DropboxClient.ERROR:
              return callback(_this.authError);
          }
        };
      })(this);
      _fsmStep();
      return this;
    };

    Client.prototype.signOut = function(callback) {
      var params, url;
      url = this.urls.signOut;
      params = this.oauth.addAuthParams('POST', url, {});
      return Dropbox.Xhr.request('POST', url, params, null, (function(_this) {
        return function(error) {
          if (error) {
            return callback(error);
          }
          _this.reset();
          _this.authState = DropboxClient.SIGNED_OFF;
          if (_this.driver.onAuthStateChange) {
            return _this.driver.onAuthStateChange(_this, function() {
              return callback(error);
            });
          } else {
            return callback(error);
          }
        };
      })(this));
    };

    Client.prototype.signOff = function(callback) {
      return this.signOut(callback);
    };

    Client.prototype.getUserInfo = function(callback) {
      var params, url;
      url = this.urls.accountInfo;
      params = this.oauth.addAuthParams('GET', url, {});
      return Dropbox.Xhr.request('GET', url, params, null, function(error, userData) {
        return callback(error, Dropbox.UserInfo.parse(userData), userData);
      });
    };

    Client.prototype.readFile = function(path, options, callback) {
      var params, responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.getFile + "/" + (this.urlEncodePath(path));
      params = {};
      responseType = null;
      if (options) {
        if (options.versionTag) {
          params.rev = options.versionTag;
        } else if (options.rev) {
          params.rev = options.rev;
        }
        if (options.blob) {
          responseType = 'blob';
        }
        if (options.binary) {
          responseType = 'b';
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request2('GET', url, params, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.writeFile = function(path, data, options, callback) {
      var useForm;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      useForm = Dropbox.Xhr.canSendForms && typeof data === 'object';
      if (useForm) {
        return this.writeFileUsingForm(path, data, options, callback);
      } else {
        return this.writeFileUsingPut(path, data, options, callback);
      }
    };

    Client.prototype.writeFileUsingForm = function(path, data, options, callback) {
      var fileField, fileName, params, slashIndex, url;
      slashIndex = path.lastIndexOf('/');
      if (slashIndex === -1) {
        fileName = path;
        path = '';
      } else {
        fileName = path.substring(slashIndex);
        path = path.substring(0, slashIndex);
      }
      url = "" + this.urls.postFile + "/" + (this.urlEncodePath(path));
      params = {
        file: fileName
      };
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      delete params.file;
      fileField = {
        name: 'file',
        value: data,
        fileName: fileName,
        contentType: 'application/octet-stream'
      };
      return Dropbox.Xhr.multipartRequest(url, fileField, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.writeFileUsingPut = function(path, data, options, callback) {
      var params, url;
      url = "" + this.urls.putFile + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.noOverwrite) {
          params.overwrite = 'false';
        }
        if (options.lastVersionTag) {
          params.parent_rev = options.lastVersionTag;
        } else if (options.parentRev || options.parent_rev) {
          params.parent_rev = options.parentRev || options.parent_rev;
        }
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request2('POST', url, params, null, data, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.stat = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.metadata + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.version != null) {
          params.rev = options.version;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = 'true';
        }
        if (options.readDir) {
          params.list = 'true';
          if (options.readDir !== true) {
            params.file_limit = options.readDir.toString();
          }
        }
        if (options.cacheHash) {
          params.hash = options.cacheHash;
        }
      }
      params.include_deleted || (params.include_deleted = 'false');
      params.list || (params.list = 'false');
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, metadata) {
        var entries, entry, stat;
        stat = Dropbox.Stat.parse(metadata);
        if (metadata != null ? metadata.contents : void 0) {
          entries = (function() {
            var _i, _len, _ref, _results;
            _ref = metadata.contents;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              entry = _ref[_i];
              _results.push(Dropbox.Stat.parse(entry));
            }
            return _results;
          })();
        } else {
          entries = void 0;
        }
        return callback(error, stat, entries);
      });
    };

    Client.prototype.readdir = function(path, options, callback) {
      var statOptions;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      statOptions = {
        readDir: true
      };
      if (options) {
        if (options.limit != null) {
          statOptions.readDir = options.limit;
        }
        if (options.versionTag) {
          statOptions.versionTag = options.versionTag;
        }
      }
      return this.stat(path, statOptions, function(error, stat, entry_stats) {
        var entries, entry_stat;
        if (entry_stats) {
          entries = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = entry_stats.length; _i < _len; _i++) {
              entry_stat = entry_stats[_i];
              _results.push(entry_stat.name);
            }
            return _results;
          })();
        } else {
          entries = null;
        }
        return callback(error, entries, stat, entry_stats);
      });
    };

    Client.prototype.metadata = function(path, options, callback) {
      return this.stat(path, options, callback);
    };

    Client.prototype.makeUrl = function(path, options, callback) {
      var isDirect, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      path = this.urlEncodePath(path);
      if (options && options.download) {
        isDirect = true;
        url = "" + this.urls.media + "/" + path;
      } else {
        isDirect = false;
        url = "" + this.urls.shares + "/" + path;
      }
      if (options && (options['long'] || options.longUrl)) {
        params = {
          short_url: 'false'
        };
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, urlData) {
        return callback(error, Dropbox.PublicUrl.parse(urlData, isDirect));
      });
    };

    Client.prototype.history = function(path, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.revisions + "/" + (this.urlEncodePath(path));
      params = {};
      if (options && (options.limit != null)) {
        params.rev_limit = options.limit;
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, versions) {
        var metadata, stats;
        if (versions) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = versions.length; _i < _len; _i++) {
              metadata = versions[_i];
              _results.push(Dropbox.Stat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.revisions = function(path, options, callback) {
      return this.history(path, options, callback);
    };

    Client.prototype.thumbnailUrl = function(path, options) {
      var params, url;
      url = "" + this.urls.thumbnails + "/" + (this.urlEncodePath(path));
      params = {};
      if (options) {
        if (options.format) {
          params.format = options.format;
        } else if (options.png) {
          params.format = 'png';
        }
        if (options.size) {
          params.size = options.size;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return "" + url + "?" + (Dropbox.Xhr.urlEncode(params));
    };

    Client.prototype.readThumbnail = function(path, options, callback) {
      var responseType, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = this.thumbnailUrl(path, options);
      responseType = 'b';
      if (options) {
        if (options.blob) {
          responseType = 'blob';
        }
      }
      return Dropbox.Xhr.request2('GET', url, {}, null, null, responseType, function(error, data, metadata) {
        return callback(error, data, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.revertFile = function(path, versionTag, callback) {
      var params, url;
      url = "" + this.urls.restore + "/" + (this.urlEncodePath(path));
      params = {
        rev: versionTag
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.restore = function(path, versionTag, callback) {
      return this.revertFile(path, versionTag, callback);
    };

    Client.prototype.findByName = function(path, namePattern, options, callback) {
      var params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      url = "" + this.urls.search + "/" + (this.urlEncodePath(path));
      params = {
        query: namePattern
      };
      if (options) {
        if (options.limit != null) {
          params.file_limit = options.limit;
        }
        if (options.removed || options.deleted) {
          params.include_deleted = true;
        }
      }
      this.oauth.addAuthParams('GET', url, params);
      return Dropbox.Xhr.request('GET', url, params, null, function(error, results) {
        var metadata, stats;
        if (results) {
          stats = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = results.length; _i < _len; _i++) {
              metadata = results[_i];
              _results.push(Dropbox.Stat.parse(metadata));
            }
            return _results;
          })();
        } else {
          stats = void 0;
        }
        return callback(error, stats);
      });
    };

    Client.prototype.search = function(path, namePattern, options, callback) {
      return this.findByName(path, namePattern, options, callback);
    };

    Client.prototype.makeCopyReference = function(path, callback) {
      var params, url;
      url = "" + this.urls.copyRef + "/" + (this.urlEncodePath(path));
      params = this.oauth.addAuthParams('GET', url, {});
      return Dropbox.Xhr.request('GET', url, params, null, function(error, refData) {
        return callback(error, Dropbox.CopyReference.parse(refData));
      });
    };

    Client.prototype.copyRef = function(path, callback) {
      return this.makeCopyReference(path, callback);
    };

    Client.prototype.pullChanges = function(cursor, callback) {
      var params, url;
      if ((!callback) && (typeof cursor === 'function')) {
        callback = cursor;
        cursor = null;
      }
      url = this.urls.delta;
      params = {};
      if (cursor) {
        if (cursor.cursorTag) {
          params = {
            cursor: cursor.cursorTag
          };
        } else {
          params = {
            cursor: cursor
          };
        }
      } else {
        params = {};
      }
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, deltaInfo) {
        return callback(error, Dropbox.PulledChanges.parse(deltaInfo));
      });
    };

    Client.prototype.delta = function(cursor, callback) {
      return this.pullChanges(cursor, callback);
    };

    Client.prototype.mkdir = function(path, callback) {
      var params, url;
      url = this.urls.fileopsCreateFolder;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.remove = function(path, callback) {
      var params, url;
      url = this.urls.fileopsDelete;
      params = {
        root: this.fileRoot,
        path: this.normalizePath(path)
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.unlink = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype["delete"] = function(path, callback) {
      return this.remove(path, callback);
    };

    Client.prototype.copy = function(from, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      params = {
        root: this.fileRoot,
        to_path: this.normalizePath(toPath)
      };
      if (from instanceof Dropbox.CopyReference) {
        params.from_copy_ref = from.tag;
      } else {
        params.from_path = this.normalizePath(from);
      }
      url = this.urls.fileopsCopy;
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.move = function(fromPath, toPath, callback) {
      var options, params, url;
      if ((!callback) && (typeof options === 'function')) {
        callback = options;
        options = null;
      }
      fromPath = this.normalizePath(fromPath);
      toPath = this.normalizePath(toPath);
      url = this.urls.fileopsMove;
      params = {
        root: this.fileRoot,
        from_path: fromPath,
        to_path: toPath
      };
      this.oauth.addAuthParams('POST', url, params);
      return Dropbox.Xhr.request('POST', url, params, null, function(error, metadata) {
        return callback(error, Dropbox.Stat.parse(metadata));
      });
    };

    Client.prototype.reset = function() {
      this.uid = null;
      this.oauth.setToken(null, '');
      this.authState = DropboxClient.RESET;
      this.authError = null;
      this._credentials = null;
      return this;
    };

    Client.prototype.setCredentials = function(credentials) {
      this.oauth.reset(credentials);
      this.uid = credentials.uid || null;
      if (credentials.authState) {
        this.authState = credentials.authState;
      } else {
        if (credentials.token) {
          this.authState = DropboxClient.DONE;
        } else {
          this.authState = DropboxClient.RESET;
        }
      }
      this.authError = null;
      this._credentials = null;
      return this;
    };

    Client.prototype.appHash = function() {
      return this.oauth.appHash();
    };

    Client.prototype.setupUrls = function() {
      this.fileRoot = this.sandbox ? 'sandbox' : 'dropbox';
      return this.urls = {
        requestToken: "" + this.apiServer + "/1/oauth/request_token",
        authorize: "" + this.authServer + "/1/oauth/authorize",
        accessToken: "" + this.apiServer + "/1/oauth/access_token",
        signOut: "" + this.apiServer + "/1/unlink_access_token",
        accountInfo: "" + this.apiServer + "/1/account/info",
        getFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        postFile: "" + this.fileServer + "/1/files/" + this.fileRoot,
        putFile: "" + this.fileServer + "/1/files_put/" + this.fileRoot,
        metadata: "" + this.apiServer + "/1/metadata/" + this.fileRoot,
        delta: "" + this.apiServer + "/1/delta",
        revisions: "" + this.apiServer + "/1/revisions/" + this.fileRoot,
        restore: "" + this.apiServer + "/1/restore/" + this.fileRoot,
        search: "" + this.apiServer + "/1/search/" + this.fileRoot,
        shares: "" + this.apiServer + "/1/shares/" + this.fileRoot,
        media: "" + this.apiServer + "/1/media/" + this.fileRoot,
        copyRef: "" + this.apiServer + "/1/copy_ref/" + this.fileRoot,
        thumbnails: "" + this.fileServer + "/1/thumbnails/" + this.fileRoot,
        fileopsCopy: "" + this.apiServer + "/1/fileops/copy",
        fileopsCreateFolder: "" + this.apiServer + "/1/fileops/create_folder",
        fileopsDelete: "" + this.apiServer + "/1/fileops/delete",
        fileopsMove: "" + this.apiServer + "/1/fileops/move"
      };
    };

    Client.ERROR = 0;

    Client.RESET = 1;

    Client.REQUEST = 2;

    Client.AUTHORIZED = 3;

    Client.DONE = 4;

    Client.SIGNED_OFF = 5;

    Client.prototype.urlEncodePath = function(path) {
      return Dropbox.Xhr.urlEncodeValue(this.normalizePath(path)).replace(/%2F/gi, '/');
    };

    Client.prototype.normalizePath = function(path) {
      var i;
      if (path.substring(0, 1) === '/') {
        i = 1;
        while (path.substring(i, i + 1) === '/') {
          i += 1;
        }
        return path.substring(i);
      } else {
        return path;
      }
    };

    Client.prototype.requestToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.requestToken, {});
      return Dropbox.Xhr.request('POST', this.urls.requestToken, params, null, callback);
    };

    Client.prototype.authorizeUrl = function(token) {
      var params;
      params = {
        oauth_token: token,
        oauth_callback: this.driver.url()
      };
      return ("" + this.urls.authorize + "?") + Dropbox.Xhr.urlEncode(params);
    };

    Client.prototype.getAccessToken = function(callback) {
      var params;
      params = this.oauth.addAuthParams('POST', this.urls.accessToken, {});
      return Dropbox.Xhr.request('POST', this.urls.accessToken, params, null, callback);
    };

    Client.prototype.defaultApiServer = function() {
      return 'https://api.dropbox.com';
    };

    Client.prototype.defaultAuthServer = function() {
      return this.apiServer.replace('api.', 'www.');
    };

    Client.prototype.defaultFileServer = function() {
      return this.apiServer.replace('api.', 'api-content.');
    };

    Client.prototype.computeCredentials = function() {
      var value;
      value = {
        key: this.oauth.key,
        sandbox: this.sandbox
      };
      if (this.oauth.secret) {
        value.secret = this.oauth.secret;
      }
      if (this.oauth.token) {
        value.token = this.oauth.token;
        value.tokenSecret = this.oauth.tokenSecret;
      }
      if (this.uid) {
        value.uid = this.uid;
      }
      if (this.authState !== DropboxClient.ERROR && this.authState !== DropboxClient.RESET && this.authState !== DropboxClient.DONE && this.authState !== DropboxClient.SIGNED_OFF) {
        value.authState = this.authState;
      }
      if (this.apiServer !== this.defaultApiServer()) {
        value.server = this.apiServer;
      }
      if (this.authServer !== this.defaultAuthServer()) {
        value.authServer = this.authServer;
      }
      if (this.fileServer !== this.defaultFileServer()) {
        value.fileServer = this.fileServer;
      }
      return this._credentials = value;
    };

    return Client;

  })();

  DropboxClient = Dropbox.Client;

  Dropbox.AuthDriver = (function() {
    function AuthDriver() {}

    AuthDriver.prototype.url = function() {
      return 'https://some.url';
    };

    AuthDriver.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      return callback('oauth-token');
    };

    AuthDriver.prototype.onAuthStateChange = function(client, done) {
      return done();
    };

    return AuthDriver;

  })();

  Dropbox.Drivers = {};

  Dropbox.Drivers.Redirect = (function() {
    function Redirect(options) {
      this.rememberUser = (options != null ? options.rememberUser : void 0) || false;
      this.scope = (options != null ? options.scope : void 0) || 'default';
      this.useQuery = (options != null ? options.useQuery : void 0) || false;
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    Redirect.prototype.url = function() {
      return this.receiverUrl;
    };

    Redirect.prototype.doAuthorize = function(authUrl) {
      return window.location.assign(authUrl);
    };

    Redirect.prototype.onAuthStateChange = function(client, done) {
      var credentials;
      this.storageKey = "dropbox-auth:" + this.scope + ":" + (client.appHash());
      switch (client.authState) {
        case DropboxClient.RESET:
          if (!(credentials = this.loadCredentials())) {
            return done();
          }
          if (credentials.authState) {
            if (credentials.token === this.locationToken()) {
              if (credentials.authState === DropboxClient.REQUEST) {
                this.forgetCredentials();
                credentials.authState = DropboxClient.AUTHORIZED;
              }
              client.setCredentials(credentials);
            }
            return done();
          }
          if (!this.rememberUser) {
            this.forgetCredentials();
            return done();
          }
          client.setCredentials(credentials);
          return client.getUserInfo((function(_this) {
            return function(error) {
              if (error) {
                client.reset();
                _this.forgetCredentials();
              }
              return done();
            };
          })(this));
        case DropboxClient.REQUEST:
          this.storeCredentials(client.credentials());
          return done();
        case DropboxClient.DONE:
          if (this.rememberUser) {
            this.storeCredentials(client.credentials());
          }
          return done();
        case DropboxClient.SIGNED_OFF:
          this.forgetCredentials();
          return done();
        case DropboxClient.ERROR:
          this.forgetCredentials();
          return done();
        default:
          return done();
      }
    };

    Redirect.prototype.computeUrl = function() {
      var fragment, location, locationPair, querySuffix;
      querySuffix = "_dropboxjs_scope=" + (encodeURIComponent(this.scope));
      location = Dropbox.Drivers.Redirect.currentLocation();
      if (location.indexOf('#') === -1) {
        fragment = null;
      } else {
        locationPair = location.split('#', 2);
        location = locationPair[0];
        fragment = locationPair[1];
      }
      if (this.useQuery) {
        if (location.indexOf('?') === -1) {
          location += "?" + querySuffix;
        } else {
          location += "&" + querySuffix;
        }
      } else {
        fragment = "?" + querySuffix;
      }
      if (fragment) {
        return location + '#' + fragment;
      } else {
        return location;
      }
    };

    Redirect.prototype.locationToken = function() {
      var location, match, scopePattern;
      location = Dropbox.Drivers.Redirect.currentLocation();
      scopePattern = "_dropboxjs_scope=" + (encodeURIComponent(this.scope)) + "&";
      if ((typeof location.indexOf === "function" ? location.indexOf(scopePattern) : void 0) === -1) {
        return null;
      }
      match = this.tokenRe.exec(location);
      if (match) {
        return decodeURIComponent(match[2]);
      } else {
        return null;
      }
    };

    Redirect.currentLocation = function() {
      return window.location.href;
    };

    Redirect.prototype.storeCredentials = function(credentials) {
      return localStorage.setItem(this.storageKey, JSON.stringify(credentials));
    };

    Redirect.prototype.loadCredentials = function() {
      var e, jsonString;
      jsonString = localStorage.getItem(this.storageKey);
      if (!jsonString) {
        return null;
      }
      try {
        return JSON.parse(jsonString);
      } catch (_error) {
        e = _error;
        return null;
      }
    };

    Redirect.prototype.forgetCredentials = function() {
      return localStorage.removeItem(this.storageKey);
    };

    return Redirect;

  })();

  Dropbox.Drivers.Popup = (function() {
    function Popup(options) {
      this.receiverUrl = this.computeUrl(options);
      this.tokenRe = new RegExp("(#|\\?|&)oauth_token=([^&#]+)(&|#|$)");
    }

    Popup.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.listenForMessage(token, callback);
      return this.openWindow(authUrl);
    };

    Popup.prototype.url = function() {
      return this.receiverUrl;
    };

    Popup.prototype.computeUrl = function(options) {
      var fragments;
      if (options) {
        if (options.receiverUrl) {
          if (options.noFragment || options.receiverUrl.indexOf('#') !== -1) {
            return options.receiverUrl;
          } else {
            return options.receiverUrl + '#';
          }
        } else if (options.receiverFile) {
          fragments = Dropbox.Drivers.Popup.currentLocation().split('/');
          fragments[fragments.length - 1] = options.receiverFile;
          if (options.noFragment) {
            return fragments.join('/');
          } else {
            return fragments.join('/') + '#';
          }
        }
      }
      return Dropbox.Drivers.Popup.currentLocation();
    };

    Popup.currentLocation = function() {
      return window.location.href;
    };

    Popup.prototype.openWindow = function(url) {
      return window.open(url, '_dropboxOauthSigninWindow', this.popupWindowSpec(980, 980));
    };

    Popup.prototype.popupWindowSpec = function(popupWidth, popupHeight) {
      var height, popupLeft, popupTop, width, x0, y0, _ref, _ref1, _ref2, _ref3;
      x0 = (_ref = window.screenX) != null ? _ref : window.screenLeft;
      y0 = (_ref1 = window.screenY) != null ? _ref1 : window.screenTop;
      width = (_ref2 = window.outerWidth) != null ? _ref2 : document.documentElement.clientWidth;
      height = (_ref3 = window.outerHeight) != null ? _ref3 : document.documentElement.clientHeight;
      popupLeft = Math.round(x0 + (width - popupWidth) / 2);
      popupTop = Math.round(y0 + (height - popupHeight) / 2.5);
      return ("width=" + popupWidth + ",height=" + popupHeight + ",") + ("left=" + popupLeft + ",top=" + popupTop) + 'dialog=yes,dependent=yes,scrollbars=yes,location=yes';
    };

    Popup.prototype.listenForMessage = function(token, callback) {
      var listener, tokenRe;
      tokenRe = this.tokenRe;
      listener = function(event) {
        var match;
        match = tokenRe.exec(event.data.toString());
        if (match && decodeURIComponent(match[2]) === token) {
          window.removeEventListener('message', listener);
          return callback();
        }
      };
      return window.addEventListener('message', listener, false);
    };

    return Popup;

  })();

  Dropbox.Drivers.NodeServer = (function() {
    function NodeServer(options) {
      this.port = (options != null ? options.port : void 0) || 8912;
      this.faviconFile = (options != null ? options.favicon : void 0) || null;
      this.fs = require('fs');
      this.http = require('http');
      this.open = require('open');
      this.callbacks = {};
      this.urlRe = new RegExp("^/oauth_callback\\?");
      this.tokenRe = new RegExp("(\\?|&)oauth_token=([^&]+)(&|$)");
      this.createApp();
    }

    NodeServer.prototype.url = function() {
      return "http://localhost:" + this.port + "/oauth_callback";
    };

    NodeServer.prototype.doAuthorize = function(authUrl, token, tokenSecret, callback) {
      this.callbacks[token] = callback;
      return this.openBrowser(authUrl);
    };

    NodeServer.prototype.openBrowser = function(url) {
      if (!url.match(/^https?:\/\//)) {
        throw new Error("Not a http/https URL: " + url);
      }
      return this.open(url);
    };

    NodeServer.prototype.createApp = function() {
      this.app = this.http.createServer((function(_this) {
        return function(request, response) {
          return _this.doRequest(request, response);
        };
      })(this));
      return this.app.listen(this.port);
    };

    NodeServer.prototype.closeServer = function() {
      return this.app.close();
    };

    NodeServer.prototype.doRequest = function(request, response) {
      var data, match, token;
      if (this.urlRe.exec(request.url)) {
        match = this.tokenRe.exec(request.url);
        if (match) {
          token = decodeURIComponent(match[2]);
          if (this.callbacks[token]) {
            this.callbacks[token]();
            delete this.callbacks[token];
          }
        }
      }
      data = '';
      request.on('data', function(dataFragment) {
        return data += dataFragment;
      });
      return request.on('end', (function(_this) {
        return function() {
          if (_this.faviconFile && (request.url === '/favicon.ico')) {
            return _this.sendFavicon(response);
          } else {
            return _this.closeBrowser(response);
          }
        };
      })(this));
    };

    NodeServer.prototype.closeBrowser = function(response) {
      var closeHtml;
      closeHtml = "<!doctype html>\n<script type=\"text/javascript\">window.close();</script>\n<p>Please close this window.</p>";
      response.writeHead(200, {
        'Content-Length': closeHtml.length,
        'Content-Type': 'text/html'
      });
      response.write(closeHtml);
      return response.end;
    };

    NodeServer.prototype.sendFavicon = function(response) {
      return this.fs.readFile(this.faviconFile, function(error, data) {
        response.writeHead(200, {
          'Content-Length': data.length,
          'Content-Type': 'image/x-icon'
        });
        response.write(data);
        return response.end;
      });
    };

    return NodeServer;

  })();

  base64HmacSha1 = function(string, key) {
    return arrayToBase64(hmacSha1(stringToArray(string), stringToArray(key), string.length, key.length));
  };

  base64Sha1 = function(string) {
    return arrayToBase64(sha1(stringToArray(string), string.length));
  };

  if (typeof window === "undefined" || window === null) {
    crypto = require('crypto');
    base64HmacSha1 = function(string, key) {
      var hmac;
      hmac = crypto.createHmac('sha1', key);
      hmac.update(string);
      return hmac.digest('base64');
    };
    base64Sha1 = function(string) {
      var hash;
      hash = crypto.createHash('sha1');
      hash.update(string);
      return hash.digest('base64');
    };
  }

  hmacSha1 = function(string, key, length, keyLength) {
    var hash1, i, ipad, opad;
    if (key.length > 16) {
      key = sha1(key, keyLength);
    }
    ipad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x36363636);
      }
      return _results;
    })();
    opad = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; _i < 16; i = ++_i) {
        _results.push(key[i] ^ 0x5C5C5C5C);
      }
      return _results;
    })();
    hash1 = sha1(ipad.concat(string), 64 + length);
    return sha1(opad.concat(hash1), 64 + 20);
  };

  sha1 = function(string, length) {
    var a, a0, b, b0, c, c0, d, d0, e, e0, ft, i, j, kt, limit, state, t, _i;
    string[length >> 2] |= 1 << (31 - ((length & 0x03) << 3));
    string[(((length + 8) >> 6) << 4) + 15] = length << 3;
    state = Array(80);
    a = 1732584193;
    b = -271733879;
    c = -1732584194;
    d = 271733878;
    e = -1009589776;
    i = 0;
    limit = string.length;
    while (i < limit) {
      a0 = a;
      b0 = b;
      c0 = c;
      d0 = d;
      e0 = e;
      for (j = _i = 0; _i < 80; j = ++_i) {
        if (j < 16) {
          state[j] = string[i + j];
        } else {
          state[j] = rotateLeft32(state[j - 3] ^ state[j - 8] ^ state[j - 14] ^ state[j - 16], 1);
        }
        if (j < 20) {
          ft = (b & c) | ((~b) & d);
          kt = 1518500249;
        } else if (j < 40) {
          ft = b ^ c ^ d;
          kt = 1859775393;
        } else if (j < 60) {
          ft = (b & c) | (b & d) | (c & d);
          kt = -1894007588;
        } else {
          ft = b ^ c ^ d;
          kt = -899497514;
        }
        t = add32(add32(rotateLeft32(a, 5), ft), add32(add32(e, state[j]), kt));
        e = d;
        d = c;
        c = rotateLeft32(b, 30);
        b = a;
        a = t;
      }
      a = add32(a, a0);
      b = add32(b, b0);
      c = add32(c, c0);
      d = add32(d, d0);
      e = add32(e, e0);
      i += 16;
    }
    return [a, b, c, d, e];
  };


  /*
   * Uncomment the definition below for debugging.
   *
   * Returns the hexadecimal representation of a 32-bit number.
  xxx = (n) ->
    if n < 0
      n = (1 << 30) * 4 + n
    n.toString 16
   */

  rotateLeft32 = function(value, count) {
    return (value << count) | (value >>> (32 - count));
  };

  add32 = function(a, b) {
    var high, low;
    low = (a & 0xFFFF) + (b & 0xFFFF);
    high = (a >> 16) + (b >> 16) + (low >> 16);
    return (high << 16) | (low & 0xFFFF);
  };

  arrayToBase64 = function(array) {
    var i, i2, limit, string, trit;
    string = "";
    i = 0;
    limit = array.length * 4;
    while (i < limit) {
      i2 = i;
      trit = ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 16;
      i2 += 1;
      trit |= ((array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF) << 8;
      i2 += 1;
      trit |= (array[i2 >> 2] >> ((3 - (i2 & 3)) << 3)) & 0xFF;
      string += _base64Digits[(trit >> 18) & 0x3F];
      string += _base64Digits[(trit >> 12) & 0x3F];
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[(trit >> 6) & 0x3F];
      }
      i += 1;
      if (i >= limit) {
        string += '=';
      } else {
        string += _base64Digits[trit & 0x3F];
      }
      i += 1;
    }
    return string;
  };

  _base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  stringToArray = function(string) {
    var array, i, mask, _i, _ref;
    array = [];
    mask = 0xFF;
    for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      array[i >> 2] |= (string.charCodeAt(i) & mask) << ((3 - (i & 3)) << 3);
    }
    return array;
  };

  Dropbox.Oauth = (function() {
    function Oauth(options) {
      this.key = this.k = null;
      this.secret = this.s = null;
      this.token = null;
      this.tokenSecret = null;
      this._appHash = null;
      this.reset(options);
    }

    Oauth.prototype.reset = function(options) {
      var k, s, secret, _ref;
      if (options.secret) {
        this.k = this.key = options.key;
        this.s = this.secret = options.secret;
        this._appHash = null;
      } else if (options.key) {
        this.key = options.key;
        this.secret = null;
        secret = atob(dropboxEncodeKey(this.key).split('|', 2)[1]);
        _ref = secret.split('?', 2), k = _ref[0], s = _ref[1];
        this.k = decodeURIComponent(k);
        this.s = decodeURIComponent(s);
        this._appHash = null;
      } else {
        if (!this.k) {
          throw new Error('No API key supplied');
        }
      }
      if (options.token) {
        return this.setToken(options.token, options.tokenSecret);
      } else {
        return this.setToken(null, '');
      }
    };

    Oauth.prototype.setToken = function(token, tokenSecret) {
      if (token && (!tokenSecret)) {
        throw new Error('No secret supplied with the user token');
      }
      this.token = token;
      this.tokenSecret = tokenSecret || '';
      this.hmacKey = DropboxXhr.urlEncodeValue(this.s) + '&' + DropboxXhr.urlEncodeValue(tokenSecret);
      return null;
    };

    Oauth.prototype.authHeader = function(method, url, params) {
      var header, oauth_params, param, value, _i, _len;
      this.addAuthParams(method, url, params);
      oauth_params = [];
      for (param in params) {
        value = params[param];
        if (param.substring(0, 6) === 'oauth_') {
          oauth_params.push(param);
        }
      }
      oauth_params.sort();
      header = [];
      for (_i = 0, _len = oauth_params.length; _i < _len; _i++) {
        param = oauth_params[_i];
        header.push(DropboxXhr.urlEncodeValue(param) + '="' + DropboxXhr.urlEncodeValue(params[param]) + '"');
        delete params[param];
      }
      return 'OAuth ' + header.join(',');
    };

    Oauth.prototype.addAuthParams = function(method, url, params) {
      this.boilerplateParams(params);
      params.oauth_signature = this.signature(method, url, params);
      return params;
    };

    Oauth.prototype.boilerplateParams = function(params) {
      params.oauth_consumer_key = this.k;
      params.oauth_nonce = this.nonce();
      params.oauth_signature_method = 'HMAC-SHA1';
      if (this.token) {
        params.oauth_token = this.token;
      }
      params.oauth_timestamp = Math.floor(Date.now() / 1000);
      params.oauth_version = '1.0';
      return params;
    };

    Oauth.prototype.nonce = function() {
      return Date.now().toString(36) + Math.random().toString(36);
    };

    Oauth.prototype.signature = function(method, url, params) {
      var string;
      string = method.toUpperCase() + '&' + DropboxXhr.urlEncodeValue(url) + '&' + DropboxXhr.urlEncodeValue(DropboxXhr.urlEncode(params));
      return base64HmacSha1(string, this.hmacKey);
    };

    Oauth.prototype.appHash = function() {
      if (this._appHash) {
        return this._appHash;
      }
      return this._appHash = base64Sha1(this.k).replace(/\=/g, '');
    };

    return Oauth;

  })();

  if (Date.now == null) {
    Date.now = function() {
      return (new Date()).getTime();
    };
  }

  DropboxOauth = Dropbox.Oauth;

  dropboxEncodeKey = function(key, secret) {
    var i, k, result, s, x, y, z, _i, _j, _ref, _ref1, _results;
    if (secret) {
      secret = [encodeURIComponent(key), encodeURIComponent(secret)].join('?');
      key = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = key.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(((key.charCodeAt(i * 2) & 15) * 16) + (key.charCodeAt(i * 2 + 1) & 15));
        }
        return _results;
      })();
    } else {
      _ref = key.split('|', 2), key = _ref[0], secret = _ref[1];
      key = atob(key);
      key = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = key.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(key.charCodeAt(i));
        }
        return _results;
      })();
      secret = atob(secret);
    }
    s = (function() {
      _results = [];
      for (_i = 0; _i < 256; _i++){ _results.push(_i); }
      return _results;
    }).apply(this);
    y = 0;
    for (x = _j = 0; _j < 256; x = ++_j) {
      y = (y + s[i] + key[x % key.length]) % 256;
      _ref1 = [s[y], s[x]], s[x] = _ref1[0], s[y] = _ref1[1];
    }
    x = y = 0;
    result = (function() {
      var _k, _ref2, _ref3, _results1;
      _results1 = [];
      for (z = _k = 0, _ref2 = secret.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; z = 0 <= _ref2 ? ++_k : --_k) {
        x = (x + 1) % 256;
        y = (y + s[x]) % 256;
        _ref3 = [s[y], s[x]], s[x] = _ref3[0], s[y] = _ref3[1];
        k = s[(s[x] + s[y]) % 256];
        _results1.push(String.fromCharCode((k ^ secret.charCodeAt(z)) % 256));
      }
      return _results1;
    })();
    key = (function() {
      var _k, _ref2, _results1;
      _results1 = [];
      for (i = _k = 0, _ref2 = key.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        _results1.push(String.fromCharCode(key[i]));
      }
      return _results1;
    })();
    return [btoa(key.join('')), btoa(result.join(''))].join('|');
  };

  Dropbox.PulledChanges = (function() {
    PulledChanges.parse = function(deltaInfo) {
      if (deltaInfo && typeof deltaInfo === 'object') {
        return new Dropbox.PulledChanges(deltaInfo);
      } else {
        return deltaInfo;
      }
    };

    PulledChanges.prototype.blankSlate = void 0;

    PulledChanges.prototype.cursorTag = void 0;

    PulledChanges.prototype.changes = void 0;

    PulledChanges.prototype.shouldPullAgain = void 0;

    PulledChanges.prototype.shouldBackOff = void 0;

    function PulledChanges(deltaInfo) {
      var entry;
      this.blankSlate = deltaInfo.reset || false;
      this.cursorTag = deltaInfo.cursor;
      this.shouldPullAgain = deltaInfo.has_more;
      this.shouldBackOff = !this.shouldPullAgain;
      if (deltaInfo.cursor && deltaInfo.cursor.length) {
        this.changes = (function() {
          var _i, _len, _ref, _results;
          _ref = deltaInfo.entries;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            entry = _ref[_i];
            _results.push(Dropbox.PullChange.parse(entry));
          }
          return _results;
        })();
      } else {
        this.changes = [];
      }
    }

    return PulledChanges;

  })();

  Dropbox.PullChange = (function() {
    PullChange.parse = function(entry) {
      if (entry && typeof entry === 'object') {
        return new Dropbox.PullChange(entry);
      } else {
        return entry;
      }
    };

    PullChange.prototype.path = void 0;

    PullChange.prototype.wasRemoved = void 0;

    PullChange.prototype.stat = void 0;

    function PullChange(entry) {
      this.path = entry[0];
      this.stat = Dropbox.Stat.parse(entry[1]);
      if (this.stat) {
        this.wasRemoved = false;
      } else {
        this.stat = null;
        this.wasRemoved = true;
      }
    }

    return PullChange;

  })();

  Dropbox.PublicUrl = (function() {
    PublicUrl.parse = function(urlData, isDirect) {
      if (urlData && typeof urlData === 'object') {
        return new Dropbox.PublicUrl(urlData, isDirect);
      } else {
        return urlData;
      }
    };

    PublicUrl.prototype.url = void 0;

    PublicUrl.prototype.expiresAt = void 0;

    PublicUrl.prototype.isDirect = void 0;

    PublicUrl.prototype.isPreview = void 0;

    function PublicUrl(urlData, isDirect) {
      this.url = urlData.url;
      this.expiresAt = new Date(Date.parse(urlData.expires));
      if (isDirect === true) {
        this.isDirect = true;
      } else if (isDirect === false) {
        this.isDirect = false;
      } else {
        this.isDirect = Date.now() - this.expiresAt <= 86400000;
      }
      this.isPreview = !this.isDirect;
    }

    return PublicUrl;

  })();

  Dropbox.CopyReference = (function() {
    CopyReference.parse = function(refData) {
      if (refData && (typeof refData === 'object' || typeof refData === 'string')) {
        return new Dropbox.CopyReference(refData);
      } else {
        return refData;
      }
    };

    CopyReference.prototype.tag = void 0;

    CopyReference.prototype.expiresAt = void 0;

    function CopyReference(refData) {
      if (typeof refData === 'object') {
        this.tag = refData.copy_ref;
        this.expiresAt = new Date(Date.parse(refData.expires));
      } else {
        this.tag = refData;
        this.expiresAt = new Date();
      }
    }

    return CopyReference;

  })();

  Dropbox.Stat = (function() {
    Stat.parse = function(metadata) {
      if (metadata && typeof metadata === 'object') {
        return new Dropbox.Stat(metadata);
      } else {
        return metadata;
      }
    };

    Stat.prototype.path = null;

    Stat.prototype.name = null;

    Stat.prototype.inAppFolder = null;

    Stat.prototype.isFolder = null;

    Stat.prototype.isFile = null;

    Stat.prototype.isRemoved = null;

    Stat.prototype.typeIcon = null;

    Stat.prototype.versionTag = null;

    Stat.prototype.mimeType = null;

    Stat.prototype.size = null;

    Stat.prototype.humanSize = null;

    Stat.prototype.hasThumbnail = null;

    Stat.prototype.modifiedAt = null;

    Stat.prototype.clientModifiedAt = null;

    function Stat(metadata) {
      var lastIndex, nameSlash, _ref, _ref1;
      this.path = metadata.path;
      if (this.path.substring(0, 1) !== '/') {
        this.path = '/' + this.path;
      }
      lastIndex = this.path.length - 1;
      if (lastIndex >= 0 && this.path.substring(lastIndex) === '/') {
        this.path = this.path.substring(0, lastIndex);
      }
      nameSlash = this.path.lastIndexOf('/');
      this.name = this.path.substring(nameSlash + 1);
      this.isFolder = metadata.is_dir || false;
      this.isFile = !this.isFolder;
      this.isRemoved = metadata.is_deleted || false;
      this.typeIcon = metadata.icon;
      if ((_ref = metadata.modified) != null ? _ref.length : void 0) {
        this.modifiedAt = new Date(Date.parse(metadata.modified));
      } else {
        this.modifiedAt = null;
      }
      if ((_ref1 = metadata.client_mtime) != null ? _ref1.length : void 0) {
        this.clientModifiedAt = new Date(Date.parse(metadata.client_mtime));
      } else {
        this.clientModifiedAt = null;
      }
      switch (metadata.root) {
        case 'dropbox':
          this.inAppFolder = false;
          break;
        case 'app_folder':
          this.inAppFolder = true;
          break;
        default:
          this.inAppFolder = null;
      }
      this.size = metadata.bytes || 0;
      this.humanSize = metadata.size || '';
      this.hasThumbnail = metadata.thumb_exists || false;
      if (this.isFolder) {
        this.versionTag = metadata.hash;
        this.mimeType = metadata.mime_type || 'inode/directory';
      } else {
        this.versionTag = metadata.rev;
        this.mimeType = metadata.mime_type || 'application/octet-stream';
      }
    }

    return Stat;

  })();

  Dropbox.UserInfo = (function() {
    UserInfo.parse = function(userInfo) {
      if (userInfo && typeof userInfo === 'object') {
        return new Dropbox.UserInfo(userInfo);
      } else {
        return userInfo;
      }
    };

    UserInfo.prototype.name = null;

    UserInfo.prototype.email = null;

    UserInfo.prototype.countryCode = null;

    UserInfo.prototype.uid = null;

    UserInfo.prototype.referralUrl = null;

    UserInfo.prototype.publicAppUrl = null;

    UserInfo.prototype.quota = null;

    UserInfo.prototype.usedQuota = null;

    UserInfo.prototype.privateBytes = null;

    UserInfo.prototype.sharedBytes = null;

    function UserInfo(userInfo) {
      var lastIndex;
      this.name = userInfo.display_name;
      this.email = userInfo.email;
      this.countryCode = userInfo.country || null;
      this.uid = userInfo.uid.toString();
      if (userInfo.public_app_url) {
        this.publicAppUrl = userInfo.public_app_url;
        lastIndex = this.publicAppUrl.length - 1;
        if (lastIndex >= 0 && this.publicAppUrl.substring(lastIndex) === '/') {
          this.publicAppUrl = this.publicAppUrl.substring(0, lastIndex);
        }
      } else {
        this.publicAppUrl = null;
      }
      this.referralUrl = userInfo.referral_link;
      this.quota = userInfo.quota_info.quota;
      this.privateBytes = userInfo.quota_info.normal || 0;
      this.sharedBytes = userInfo.quota_info.shared || 0;
      this.usedQuota = this.privateBytes + this.sharedBytes;
    }

    return UserInfo;

  })();

  if (typeof window !== "undefined" && window !== null) {
    if (window.XDomainRequest && !('withCredentials' in new XMLHttpRequest())) {
      DropboxXhrRequest = window.XDomainRequest;
      DropboxXhrIeMode = true;
      DropboxXhrCanSendForms = false;
    } else {
      DropboxXhrRequest = window.XMLHttpRequest;
      DropboxXhrIeMode = false;
      DropboxXhrCanSendForms = window.navigator.userAgent.indexOf('Firefox') === -1;
    }
  } else {
    DropboxXhrRequest = require('xmlhttprequest').XMLHttpRequest;
    DropboxXhrIeMode = false;
    DropboxXhrCanSendForms = false;
  }

  Dropbox.Xhr = (function() {
    function Xhr() {}

    Xhr.Request = DropboxXhrRequest;

    Xhr.ieMode = DropboxXhrIeMode;

    Xhr.canSendForms = DropboxXhrCanSendForms;

    Xhr.request = function(method, url, params, authHeader, callback) {
      return this.request2(method, url, params, authHeader, null, null, callback);
    };

    Xhr.request2 = function(method, url, params, authHeader, body, responseType, callback) {
      var headers, paramsInUrl, queryString;
      paramsInUrl = method === 'GET' || (body != null) || this.ieMode;
      if (paramsInUrl) {
        queryString = DropboxXhr.urlEncode(params);
        if (queryString.length !== 0) {
          url = [url, '?', DropboxXhr.urlEncode(params)].join('');
        }
      }
      headers = {};
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      if (body != null) {
        if (typeof body === 'string') {
          headers['Content-Type'] = 'text/plain; charset=utf8';
        }
      } else if (!paramsInUrl) {
        headers['Content-Type'] = 'application/x-www-form-urlencoded';
        body = DropboxXhr.urlEncode(params);
      }
      return DropboxXhr.xhrRequest(method, url, headers, body, responseType, callback);
    };

    Xhr.multipartRequest = function(url, fileField, params, authHeader, callback) {
      var body, boundary, fileData, fileType, headers, useFormData;
      url = [url, '?', DropboxXhr.urlEncode(params)].join('');
      fileData = fileField.value;
      useFormData = (typeof fileData === 'object') && (((typeof Blob !== "undefined" && Blob !== null) && (fileField.value instanceof Blob)) || ((typeof File !== "undefined" && File !== null) && (fileField.value instanceof File)));
      if (useFormData) {
        headers = {};
        body = new FormData();
        body.append(fileField.name, fileData, fileField.fileName);
      } else {
        fileType = fileField.contentType || 'application/octet-stream';
        boundary = this.multipartBoundary();
        headers = {
          'Content-Type': "multipart/form-data; boundary=" + boundary
        };
        body = ['--', boundary, "\r\n", 'Content-Disposition: form-data; name="', fileField.name, '"; filename="', fileField.fileName, "\"\r\n", 'Content-Type: ', fileType, "\r\n", "Content-Transfer-Encoding: binary\r\n\r\n", fileData, "\r\n", '--', boundary, '--', "\r\n"].join('');
      }
      if (authHeader) {
        headers['Authorization'] = authHeader;
      }
      return DropboxXhr.xhrRequest('POST', url, headers, body, null, callback);
    };

    Xhr.multipartBoundary = function() {
      return [Date.now().toString(36), Math.random().toString(36)].join('----');
    };

    Xhr.xhrRequest = function(method, url, headers, body, responseType, callback) {
      var header, value, xhr;
      xhr = new this.Request();
      if (this.ieMode) {
        xhr.onload = function() {
          return DropboxXhr.onLoad(xhr, method, url, callback);
        };
        xhr.onerror = function() {
          return DropboxXhr.onError(xhr, method, url, callback);
        };
      } else {
        xhr.onreadystatechange = function() {
          return DropboxXhr.onReadyStateChange(xhr, method, url, responseType, callback);
        };
      }
      xhr.open(method, url, true);
      if (responseType) {
        if (responseType === 'b') {
          if (xhr.overrideMimeType) {
            xhr.overrideMimeType('text/plain; charset=x-user-defined');
          }
        } else {
          xhr.responseType = responseType;
        }
      }
      if (!this.ieMode) {
        for (header in headers) {
          if (!__hasProp.call(headers, header)) continue;
          value = headers[header];
          xhr.setRequestHeader(header, value);
        }
      }
      if (body != null) {
        xhr.send(body);
      } else {
        xhr.send();
      }
      return xhr;
    };

    Xhr.urlEncode = function(object) {
      var chunks, key, value;
      chunks = [];
      for (key in object) {
        value = object[key];
        chunks.push(this.urlEncodeValue(key) + '=' + this.urlEncodeValue(value));
      }
      return chunks.sort().join('&');
    };

    Xhr.urlEncodeValue = function(object) {
      return encodeURIComponent(object.toString()).replace(/\!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/\*/g, '%2A');
    };

    Xhr.urlDecode = function(string) {
      var kvp, result, token, _i, _len, _ref;
      result = {};
      _ref = string.split('&');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        token = _ref[_i];
        kvp = token.split('=');
        result[decodeURIComponent(kvp[0])] = decodeURIComponent(kvp[1]);
      }
      return result;
    };

    Xhr.onReadyStateChange = function(xhr, method, url, responseType, callback) {
      var apiError, bytes, dirtyText, e, i, metadata, metadataJson, text, _i, _ref;
      if (xhr.readyState !== 4) {
        return true;
      }
      if (xhr.status < 200 || xhr.status >= 300) {
        apiError = new Dropbox.ApiError(xhr, method, url);
        callback(apiError);
        return true;
      }
      metadataJson = xhr.getResponseHeader('x-dropbox-metadata');
      if (metadataJson != null ? metadataJson.length : void 0) {
        try {
          metadata = JSON.parse(metadataJson);
        } catch (_error) {
          e = _error;
          metadata = void 0;
        }
      } else {
        metadata = void 0;
      }
      if (responseType) {
        if (responseType === 'b') {
          dirtyText = xhr.responseText != null ? xhr.responseText : xhr.response;

          /*
          jsString = ['["']
          for i in [0...dirtyText.length]
            hexByte = (dirtyText.charCodeAt(i) & 0xFF).toString(16)
            if hexByte.length is 2
              jsString.push "\\u00#{hexByte}"
            else
              jsString.push "\\u000#{hexByte}"
          jsString.push '"]'
          console.log jsString
          text = JSON.parse(jsString.join(''))[0]
           */
          bytes = [];
          for (i = _i = 0, _ref = dirtyText.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            bytes.push(String.fromCharCode(dirtyText.charCodeAt(i) & 0xFF));
          }
          text = bytes.join('');
          callback(null, text, metadata);
        } else {
          callback(null, xhr.response, metadata);
        }
        return true;
      }
      text = xhr.responseText != null ? xhr.responseText : xhr.response;
      switch (xhr.getResponseHeader('Content-Type')) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), metadata);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), metadata);
          break;
        default:
          callback(null, text, metadata);
      }
      return true;
    };

    Xhr.onLoad = function(xhr, method, url, callback) {
      var text;
      text = xhr.responseText;
      switch (xhr.contentType) {
        case 'application/x-www-form-urlencoded':
          callback(null, DropboxXhr.urlDecode(text), void 0);
          break;
        case 'application/json':
        case 'text/javascript':
          callback(null, JSON.parse(text), void 0);
          break;
        default:
          callback(null, text, void 0);
      }
      return true;
    };

    Xhr.onError = function(xhr, method, url, callback) {
      var apiError;
      apiError = new Dropbox.ApiError(xhr, method, url);
      callback(apiError);
      return true;
    };

    return Xhr;

  })();

  DropboxXhr = Dropbox.Xhr;

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    module.exports = Dropbox;
  } else if (typeof window !== "undefined" && window !== null) {
    window.Dropbox = Dropbox;
  } else {
    throw new Error('This library only supports node.js and modern browsers.');
  }

  Dropbox.atob = atob;

  Dropbox.btoa = btoa;

  Dropbox.hmac = base64HmacSha1;

  Dropbox.sha1 = base64Sha1;

  Dropbox.encodeKey = dropboxEncodeKey;

  if (window.Nimbus == null) {
    Nimbus = winodw.Nimbus = {};
  }

  Nimbus = window.Nimbus;

  Nimbus.version = "0.0.1";

  $ = Nimbus.$ = this.jQuery || this.Zepto || function() {
    return arguments[0];
  };

  Nimbus.dictModel = {};

  makeArray = function(args) {
    return Array.prototype.slice.call(args, 0);
  };

  isArray = function(value) {
    return Object.prototype.toString.call(value) === "[object Array]";
  };

  if (typeof Array.prototype.indexOf === "undefined") {
    Array.prototype.indexOf = function(value) {
      var i;
      i = 0;
      while (i < this.length) {
        if (this[i] === value) {
          return i;
        }
        i++;
      }
      return -1;
    };
  }

  Events = {
    bind: function(ev, callback) {
      var calls, evs, i;
      evs = ev.split(" ");
      calls = this._callbacks || (this._callbacks = {});
      i = 0;
      while (i < evs.length) {
        (this._callbacks[evs[i]] || (this._callbacks[evs[i]] = [])).push(callback);
        i++;
      }
      return this;
    },
    trigger: function() {
      var args, calls, ev, i, l, list;
      args = makeArray(arguments);
      ev = args.shift();
      if (!(calls = this._callbacks)) {
        return false;
      }
      if (!(list = this._callbacks[ev])) {
        return false;
      }
      i = 0;
      l = list.length;
      while (i < l) {
        if (list[i].apply(this, args) === false) {
          return false;
        }
        i++;
      }
      return true;
    },
    unbind: function(ev, callback) {
      var calls, i, l, list;
      if (!ev) {
        this._callbacks = {};
        return this;
      }
      if (!(calls = this._callbacks)) {
        return this;
      }
      if (!(list = calls[ev])) {
        return this;
      }
      if (!callback) {
        delete this._callbacks[ev];
        return this;
      }
      i = 0;
      l = list.length;
      while (i < l) {
        if (callback === list[i]) {
          list = list.slice();
          list.splice(i, 1);
          calls[ev] = list;
          break;
        }
        i++;
      }
      return this;
    }
  };

  if (typeof Object.create !== "function") {
    Object.create = function(o) {
      var F;
      F = function() {};
      F.prototype = o;
      return new F();
    };
  }

  moduleKeywords = ["included", "extended"];

  Class = {
    inherited: function() {},
    created: function() {},
    prototype: {
      initialize: function() {},
      init: function() {}
    },
    create: function(include, extend) {
      var object;
      object = Object.create(this);
      object.parent = this;
      object.prototype = object.fn = Object.create(this.prototype);
      if (include) {
        object.include(include);
      }
      if (extend) {
        object.extend(extend);
      }
      object.created();
      this.inherited(object);
      return object;
    },
    init: function() {
      var instance;
      instance = Object.create(this.prototype);
      instance.parent = this;
      instance.initialize.apply(instance, arguments);
      instance.init.apply(instance, arguments);
      return instance;
    },
    proxy: function(func) {
      var thisObject;
      thisObject = this;
      return function() {
        return func.apply(thisObject, arguments);
      };
    },
    proxyAll: function() {
      var functions, i, _results;
      functions = makeArray(arguments);
      i = 0;
      _results = [];
      while (i < functions.length) {
        this[functions[i]] = this.proxy(this[functions[i]]);
        _results.push(i++);
      }
      return _results;
    },
    include: function(obj) {
      var included, key;
      for (key in obj) {
        if (moduleKeywords.indexOf(key) === -1) {
          this.fn[key] = obj[key];
        }
      }
      included = obj.included;
      if (included) {
        included.apply(this);
      }
      return this;
    },
    extend: function(obj) {
      var extended, key;
      for (key in obj) {
        if (moduleKeywords.indexOf(key) === -1) {
          this[key] = obj[key];
        }
      }
      extended = obj.extended;
      if (extended) {
        extended.apply(this);
      }
      return this;
    }
  };

  Class.prototype.proxy = Class.proxy;

  Class.prototype.proxyAll = Class.proxyAll;

  Class.inst = Class.init;

  Class.sub = Class.create;

  Nimbus.guid = function() {
    var id, verified, verify_guide;
    verify_guide = function(g_id) {
      var x, y, _ref;
      _ref = Nimbus.dictModel;
      for (x in _ref) {
        y = _ref[x];
        if (y.exists(g_id)) {
          return false;
        }
      }
      return true;
    };
    verified = false;
    while (!verified) {
      id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r, v;
        r = Math.random() * 16 | 0;
        v = (c === "x" ? r : r & 0x3 | 0x8);
        return v.toString(16);
      }).toUpperCase();
      verified = verify_guide(id);
    }
    return id;
  };

  Auth = Nimbus.Auth = Class.create();

  Auth.extend({
    reinitialize: function() {
      var cloud, service, sync_service;
      log("reintialize called");
      if (localStorage["last_sync_object"] != null) {
        log("the service exists", localStorage["service"]);
        sync_service = JSON.parse(localStorage["last_sync_object"]);
        if (Nimbus.Auth.sync_services == null) {
          Nimbus.Auth.sync_services = {};
          Nimbus.Auth.sync_services.synchronous = sync_service.synchronous;
        } else if (Nimbus.Auth.sync_services.hasOwnProperty(sync_service.service)) {
          service = Nimbus.Auth.sync_services[sync_service.service];
          if (service.app_id !== sync_service.app_id) {
            cloud = sync_service.service;
            sync_service = service;
            sync_service.service = cloud;
            localStorage.clear();
          }
        } else {
          localStorage.clear();
        }
        this.setup(sync_service);
        return this.initialize();
      }
    },
    setup: function(sync_service) {
      var item, key, service, value;
      if (typeof sync_service === "string") {
        console.log("Current sync service", sync_service);
        sync_service = JSON.parse(sync_service);
      }
      if (!this.app_name) {
        this.app_name = sync_service.app_name;
      }
      if (!this.app_name) {
        for (item in sync_service) {
          if (sync_service[item].app_name) {
            this.app_name = sync_service[item].app_name;
            if (this.app_name) {
              break;
            }
          }
        }
      }
      if (sync_service.service != null) {
        log("setup called on a service", sync_service.service);
        log("setup object", sync_service);
        for (key in sync_service) {
          value = sync_service[key];
          this[key] = value;
        }
        if ((Nimbus.Auth.sync_services != null) && (Nimbus.Auth.sync_services.synchronous != null)) {
          sync_service.synchronous = Nimbus.Auth.sync_services.synchronous;
        } else {
          sync_service.synchronous = true;
        }
        sync_service.app_name = this.app_name;
        localStorage["last_sync_object"] = JSON.stringify(sync_service);
        if (!sync_service.synchronous) {
          Nimbus.Model.Local.async_doc_setup();
        }
        switch (this.service) {
          case "Dropbox":
            this.extend(Nimbus.Auth.Dropbox_auth);
            this._authorize = this.proxy(this.authenticate_dropbox);
            this.initialize = this.proxy(this.initialize_dropbox);
            this.authorized = this.proxy(this.dropbox_authorized);
            this.logout = function() {
              this.proxy(this.logout_dropbox);
              this.clear_storage();
            };
            Nimbus.Binary.setup(this.service);
            log("service is dropbox");
            break;
          case "GDrive":
            this.extend(Nimbus.Auth.GDrive);
            this.init_scope();
            this._authorize = this.proxy(this.authenticate_gdrive);
            this.initialize = this.proxy(this.initialize_gdrive);
            this.authorized = this.proxy(this.gdrive_authorized);
            this.logout = function() {
              this.proxy(this.logout_gdrive);
              this.clear_storage();
            };
            Nimbus.Binary.setup(this.service);
            log("service is GDrive");
            Nimbus.Share.setup(this.service);
            break;
          case "Realtime":
            Nimbus.realtime.startRealtime(key, app_name);
            break;
          case "Firebase":
            log('using firebase');
            Nimbus.Firebase = {
              id: this.key,
              appName: this.app_name,
              server: new Firebase("https://" + this.key + ".firebaseio.com"),
              realtimeEvents: []
            };
            this.extend(Nimbus.Auth.Firebase);
            this._authorize = this.proxy(this.authenticate_firebase);
            this.initialize = this.proxy(this.initialize_firebase);
            this.authorized = this.proxy(this.firebase_authorized);
            this.setServer();
            Nimbus.Share.setup(this.service);
            break;
          default:
            log("Invalid service name");
        }
      } else {
        log("new method for setup, the service is there");
        this.sync_services = sync_service;
        this.models = {};
        if (localStorage["service"] != null) {
          if (localStorage["service"] === "GDrive") {
            service = this.sync_services["GDrive"];
            service["service"] = "GDrive";
            this.setup(service);
          } else {
            service = this.sync_services["Dropbox"];
            service["service"] = "Dropbox";
            this.setup(service);
          }
        } else {
          this.extend(Nimbus.Auth.Multi);
          this._authorize = this.proxy(this.authenticate_service);
          this.initialize = this.proxy(this.initialize_service);
        }
      }
      this.authorize = function(type, config) {
        var obj;
        if ((type && type !== this.service) && this.service) {
          localStorage.clear();
          obj = this.sync_services[type];
          obj.service = type;
          this.setup(obj);
        }
        return this._authorize(type, config);
      };
    },
    clear_storage: function() {
      log('Will clear localStorage or indexedDB');
      localStorage.clear();
      PouchDB.destroy(this.app_name);
    },
    authorized: function() {
      return log("authorized not yet setup");
    },
    state: function() {
      return localStorage["state"];
    },
    authorize: function() {
      return log("authorize not yet setup");
    },
    initialize: function() {
      return log("initialize not setup");
    },
    authorized_callback: function() {
      return log("authorized callback undefined");
    },
    app_ready_func: function() {
      log("app_ready");
      return this.app_ready = true;
    },
    set_app_ready: function(callback) {
      var cb;
      log("set app ready");
      if ((this.app_ready != null) && this.app_ready) {
        if (this.service === 'GDrive') {
          return Nimbus.realtime.folder_initialize(callback);
        } else {
          return callback();
        }
      } else {
        cb = function() {
          if (this.service === 'GDrive') {
            return Nimbus.realtime.folder_initialize(callback);
          } else {
            return callback();
          }
        };
        return this.app_ready_func = cb;
      }
    },
    logout: function() {
      return log("logout not implemented");
    }
  });

  Client = Nimbus.Client = Class.create();

  Share = Nimbus.Share = Class.create();

  Share.extend({
    setup: function(sync_service) {
      switch (sync_service) {
        case "GDrive":
          log("share api with GDrive");
          this.extend(Nimbus.Client.GDrive);
          this.get_users = this.proxy(this.get_shared_users);
          this.add_user = this.proxy(this.add_share_user);
          this.remove_user = this.proxy(this.remove_share_user);
          this.get_me = this.proxy(this.get_current_user);
          this.get_spaces = this.proxy(this.get_app_folders);
          this.switch_spaces = this.proxy(this.switch_to_app_folder);
          return this.switch_file_real = this.proxy(this.switch_to_app_file_real);
        case 'Firebase':
          this.extend(Nimbus.Client.Firebase);
          this._setup();
          this.get_users = this.proxy(this.get_shared_users);
          this.add_user = this.proxy(this.add_share_user);
          this.remove_user = this.proxy(this.remove_share_user);
          this.get_me = this.proxy(this.get_current_user);
          this.get_spaces = this.proxy(this.get_app_folders);
          this.switch_spaces = this.proxy(this.switch_to_app_folder);
          return this.switch_file_real = this.proxy(this.switch_to_app_file_real);
        default:
          return log("share not supported with this service");
      }
    },
    get_users: function() {
      return log("users not implemented");
    },
    add_user: function(email) {
      return log("add a user");
    },
    remove_user: function(id) {
      return log("removed user");
    },
    get_me: function() {
      return log("get currently logged user");
    },
    get_spaces: function() {
      return log("get current spaces");
    },
    switch_spaces: function(id) {
      return log("switch space");
    }
  });

  Binary = Nimbus.Binary = Class.create();

  Binary.extend({
    setup: function(sync_service) {
      log("binary setup called");
      switch (sync_service) {
        case "Dropbox":
          this.extend(Nimbus.Client.Dropbox.Binary);
          Nimbus.Client.Dropbox.Binary.binary_setup();
          return log("service is dropbox");
        case "GDrive":
          this.extend(Nimbus.Client.GDrive.Binary);
          Nimbus.Client.GDrive.Binary.binary_setup();
          return log("service is GDrive");
        case "Realtime":
          return log("service is  Realtime");
        default:
          return log("Invalid service name");
      }
    },
    upload_blob: function(blob, name, callback) {
      return log("upload blob");
    },
    upload_file: function(file, callback) {
      return log("upload blob");
    },
    read_file: function(binary, callback) {
      return log("read file");
    },
    share_link: function(binary, callback) {
      return log("share link");
    },
    direct_link: function(binary, callback) {
      return log("direct link");
    },
    delete_file: function(binary) {
      return log("delete file");
    }
  });

  DB = Nimbus.DB = Class.create();

  DB.extend(Events);

  DB.extend({
    setup_db: function(type) {
      log("setup db");
      switch (type) {
        case "localStorage":
          return Storage.prototype.setItem = function(key, value) {
            if (this === window.localStorage) {
              return log("local storage called");
            } else {
              return _setItem.apply(this, arguments);
            }
          };
      }
    }
  });

  Model = Nimbus.Model = Class.create();

  Model.extend(Events);

  Model.extend({
    loaded: false,
    check_loaded: function() {
      if (this.loaded) {
        return true;
      } else {
        console.log("The model is not loaded yet! Wait for the model to be done with setup.");
        return false;
      }
    },
    service_setup: function(model) {
      var atts;
      log("service setup model", model);
      atts = model.attributes;
      switch (Nimbus.Auth.service) {
        case "Dropbox":
          log("extend as Dropbox");
          model.extend(Nimbus.Model.general_sync);
          model.extend(Nimbus.Model.Dropbox);
          atts.push("synced");
          atts.push("time");
          model.attributes = atts;
          break;
        case "GDrive":
          log("extend as GDrive");
          model.extend(Nimbus.Model.general_sync);
          model.extend(Nimbus.Model.Realtime);
          atts.push("gid");
          atts.push("synced");
          atts.push("time");
          atts.push("type");
          model.attributes = atts;
          break;
        case "Firebase":
          log("extend as Firebase");
          model.extend(Nimbus.Model.general_sync);
          model.extend(Nimbus.Model.Firebase);
          model._setup();
          atts.push("synced");
          atts.push("time");
          atts.push("type");
          model.attributes = atts;
          break;
        default:
          log("Invalid service name");
      }
      return model;
    },
    setup: function(name, atts, callback) {
      var Deletion, model;
      log("model setup");
      model = Model.sub();
      if (name) {
        model.name = name;
      }
      if (atts) {
        model.attributes = atts;
      }
      if ((Nimbus.Auth.sync_services.synchronous != null) && Nimbus.Auth.sync_services.synchronous) {
        model.extend(Nimbus.Model.LocalSync);
      } else {
        model.extend(Nimbus.Model.Local);
      }
      Nimbus.dictModel[name] = model;
      if ((Nimbus.Auth.service != null) || (Nimbus.Auth.sync_services != null) || name === "binary" || name === "binary_Deletion") {
        log("model 1", model);
        if (name.indexOf("_Deletion") < 0) {
          model = this.service_setup(model);
        }
      } else {
        log("name:", name);
        log("Please setup Nimbus.Auth first before creating models");
      }
      if (name.indexOf("_Deletion") < 0) {
        Deletion = Nimbus.Model.setup(name + "_" + "Deletion", ["deletion_id", "listid"]);
        Deletion.extend(Nimbus.Model.Local);
        Deletion.fetch();
        model.DeletionStorage = Deletion;
      }
      log(model);
      model.fetch();
      if (name.indexOf("_Deletion") < 0) {
        Nimbus.dictModel[name] = model;
      } else {
        delete Nimbus.dictModel[name];
      }
      return model;
    },
    created: function(sub) {
      this.records = {};
      return this.attributes = (this.attributes ? makeArray(this.attributes) : []);
    },
    find: function(id) {
      var record;
      record = this.records[id];
      if (!record) {
        throw "Unknown record";
      }
      return record.clone();
    },
    exists: function(id) {
      var e;
      try {
        return this.find(id);
      } catch (_error) {
        e = _error;
        return false;
      }
    },
    refresh: function(values) {
      var i, il, record;
      values = this.fromJSON(values);
      this.records = {};
      i = 0;
      il = values.length;
      while (i < il) {
        record = values[i];
        record.newRecord = false;
        this.records[record.id] = record;
        i++;
      }
      this.trigger("refresh");
      return this;
    },
    select: function(callback) {
      var key, result;
      result = [];
      for (key in this.records) {
        if (callback(this.records[key])) {
          result.push(this.records[key]);
        }
      }
      return this.cloneArray(result);
    },
    findByAttribute: function(name, value) {
      var key;
      for (key in this.records) {
        if (this.records[key][name] === value) {
          return this.records[key].clone();
        }
      }
    },
    findAllByAttribute: function(name, value) {
      return this.select(function(item) {
        return item[name] === value;
      });
    },
    each: function(callback) {
      var key, _results;
      _results = [];
      for (key in this.records) {
        _results.push(callback(this.records[key]));
      }
      return _results;
    },
    all: function() {
      return this.cloneArray(this.recordsValues());
    },
    first: function() {
      var record;
      record = this.recordsValues()[0];
      return record && record.clone();
    },
    last: function() {
      var record, values;
      values = this.recordsValues();
      record = values[values.length - 1];
      return record && record.clone();
    },
    count: function() {
      return this.recordsValues().length;
    },
    deleteAll: function() {
      var key, _results;
      _results = [];
      for (key in this.records) {
        _results.push(delete this.records[key]);
      }
      return _results;
    },
    destroyAll: function() {
      var key, _results;
      _results = [];
      for (key in this.records) {
        _results.push(this.records[key].destroy());
      }
      return _results;
    },
    update: function(id, atts) {
      return this.find(id).updateAttributes(atts);
    },
    create: function(atts) {
      var record;
      record = this.init(atts);
      return record.save();
    },
    destroy: function(id) {
      return this.find(id).destroy();
    },
    sync: function(callback) {
      return this.bind("change", callback);
    },
    fetch: function(callbackOrParams) {
      if (!this.loaded && (callbackOrParams != null)) {
        this.loadLocal(callbackOrParams);
      }
      if (typeof callbackOrParams === "function") {
        return this.bind("fetch", callbackOrParams);
      } else {
        return this.trigger.apply(this, ["fetch"].concat(makeArray(arguments)));
      }
    },
    toJSON: function() {
      return this.recordsValues();
    },
    fromJSON: function(objects) {
      var i, results;
      if (!objects) {
        return;
      }
      if (typeof objects === "string") {
        objects = JSON.parse(objects);
      }
      if (isArray(objects)) {
        results = [];
        i = 0;
        while (i < objects.length) {
          results.push(this.init(objects[i]));
          i++;
        }
        return results;
      } else {
        return this.init(objects);
      }
    },
    recordsValues: function() {
      var key, result;
      result = [];
      for (key in this.records) {
        result.push(this.records[key]);
      }
      return result;
    },
    cloneArray: function(array) {
      var i, result;
      result = [];
      i = 0;
      while (i < array.length) {
        result.push(array[i].clone());
        i++;
      }
      return result;
    }
  });

  Model.include({
    model: true,
    newRecord: true,
    init: function(atts) {
      var parent_type;
      if (atts) {
        this.load(atts);
      }
      parent_type = this.parent.name;
      this.parent = function() {
        return Nimbus.dictModel[parent_type];
      };
      return this.trigger("init", this);
    },
    isNew: function() {
      return this.newRecord;
    },
    isValid: function() {
      return !this.validate();
    },
    validate: function() {},
    load: function(atts) {
      var name, _results;
      _results = [];
      for (name in atts) {
        _results.push(this[name] = atts[name]);
      }
      return _results;
    },
    attributes: function() {
      var attr, i, result;
      result = {};
      i = 0;
      while (i < this.parent().attributes.length) {
        attr = this.parent().attributes[i];
        result[attr] = this[attr];
        i++;
      }
      result.id = this.id;
      return result;
    },
    eql: function(rec) {
      return rec && rec.id === this.id && rec.parent() === this.parent();
    },
    save: function() {
      var error;
      error = this.validate();
      if (error) {
        this.trigger("error", this, error);
        return false;
      }
      this.trigger("beforeSave", this);
      if (this.newRecord) {
        this.create();
      } else {
        this.update();
      }
      this.trigger("save", this);
      return this;
    },
    updateAttribute: function(name, value) {
      this[name] = value;
      return this.save();
    },
    updateAttributes: function(atts) {
      this.load(atts);
      return this.save();
    },
    destroy: function() {
      this.trigger("beforeDestroy", this);
      delete this.parent().records[this.id];
      this.destroyed = true;
      this.trigger("destroy", this);
      return this.trigger("change", this, "destroy");
    },
    dup: function() {
      var result;
      result = this.parent().init(this.attributes());
      result.newRecord = this.newRecord;
      return result;
    },
    clone: function() {
      return Object.create(this);
    },
    reload: function() {
      var original;
      if (this.newRecord) {
        return this;
      }
      original = this.parent().find(this.id);
      this.load(original.attributes());
      return original;
    },
    toJSON: function() {
      return this.attributes();
    },
    exists: function() {
      return this.id && this.id in this.parent().records;
    },
    update: function() {
      var clone, records;
      this.trigger("beforeUpdate", this);
      records = this.parent().records;
      records[this.id].load(this.attributes());
      clone = records[this.id].clone();
      this.trigger("update", clone);
      return this.trigger("change", clone, "update");
    },
    create: function() {
      var clone, records;
      this.trigger("beforeCreate", this);
      if (!this.id) {
        this.id = Nimbus.guid();
      }
      this.newRecord = false;
      records = this.parent().records;
      records[this.id] = this.dup();
      clone = records[this.id].clone();
      this.trigger("create", clone);
      return this.trigger("change", clone, "create");
    },
    bind: function(events, callback) {
      return this.parent().bind(events, this.proxy(function(record) {
        if (record && this.eql(record)) {
          return callback.apply(this, arguments);
        }
      }));
    },
    trigger: function() {
      var e;
      try {
        return this.parent().trigger.apply(this.parent(), arguments);
      } catch (_error) {
        e = _error;
        return log(e);
      }
    }
  });

  Set = (function() {
    function Set(set) {
      this._set = (set === void 0 ? [] : set);
      this.length = this._set.length;
      this.contains = function(element) {
        return this._set.indexOf(element) !== -1;
      };
    }

    Set.prototype.union = function(s) {
      var A, B, i, set;
      A = (s.length > this.length ? s : this);
      B = (s.length > this.length ? this : s);
      set = A.copy();
      i = 0;
      while (i < B.length) {
        set.add(B._set[i]);
        i++;
      }
      return set;
    };

    Set.prototype.intersection = function(s) {
      var A, B, element, i, set;
      set = new Set();
      A = (s.length > this.length ? s : this);
      B = (s.length > this.length ? this : s);
      i = 0;
      while (i < B.length) {
        element = B._set[i];
        if (A.contains(element)) {
          set.add(element);
        }
        i++;
      }
      return set;
    };

    Set.prototype.difference = function(s) {
      var element, i, set;
      set = new Set();
      i = 0;
      while (i < this.length) {
        element = this._set[i];
        if (!s.contains(element)) {
          set.add(element);
        }
        i++;
      }
      return set;
    };

    Set.prototype.symmetricDifference = function(s) {
      return this.union(s).difference(this.intersection(s));
    };

    Set.prototype.isSuperSet = function(s) {
      var i;
      i = 0;
      while (i < s.length) {
        if (!this.contains(s._set[i])) {
          return false;
        }
        i++;
      }
      return true;
    };

    Set.prototype.isSubSet = function(s) {
      var i;
      i = 0;
      while (i < this.length) {
        if (!s.contains(this._set[i])) {
          return false;
        }
        i++;
      }
      return true;
    };

    Set.prototype.add = function(element) {
      if (this._set.indexOf(element) === -1) {
        this._set.push(element);
        this.length++;
      }
      return this.length;
    };

    Set.prototype.remove = function(element) {
      var i;
      i = this._set.indexOf(element);
      if (i !== -1) {
        this.length--;
        return this._set.splice(i, 1)[0];
      } else {
        return null;
      }
    };

    Set.prototype.copy = function() {
      return new Set(this._set.slice());
    };

    Set.prototype.asArray = function() {
      return this._set;
    };

    return Set;

  })();

  exports = this;

  exports.Set = Set;

  DelayedOp = (function() {
    function DelayedOp(callback) {
      this.callback = callback;
      this.ready = __bind(this.ready, this);
      this.ok = __bind(this.ok, this);
      this.wait = __bind(this.wait, this);
      this.count = 1;
    }

    DelayedOp.prototype.wait = function() {
      return this.count++;
    };

    DelayedOp.prototype.ok = function() {
      if (!--this.count) {
        return this.callback();
      }
    };

    DelayedOp.prototype.ready = function() {
      return this.ok();
    };

    return DelayedOp;

  })();

  OneOp = (function() {
    function OneOp() {
      this.execute_callback = __bind(this.execute_callback, this);
      this.add_last_call = __bind(this.add_last_call, this);
      this.add_call = __bind(this.add_call, this);
      this.running = false;
      this.callbacks = [];
    }

    OneOp.prototype.add_call = function(callback) {
      this.running = true;
      return this.callbacks.push(callback);
    };

    OneOp.prototype.add_last_call = function(callback) {
      return this.last_callback = callback;
    };

    OneOp.prototype.execute_callback = function() {
      var func, _i, _len, _ref;
      _ref = this.callbacks;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        func = _ref[_i];
        func();
      }
      this.callbacks = [];
      if (this.last_callback != null) {
        this.last_callback();
      }
      return this.running = false;
    };

    return OneOp;

  })();

  DelayedSyncAnimation = (function() {
    function DelayedSyncAnimation() {
      this.ready = __bind(this.ready, this);
      this.ok = __bind(this.ok, this);
      this.wait = __bind(this.wait, this);
      this.count = 1;
    }

    DelayedSyncAnimation.prototype.wait = function() {
      return this.count++;
    };

    DelayedSyncAnimation.prototype.ok = function() {
      if (!--this.count) {
        return log("ok executed");
      }
    };

    DelayedSyncAnimation.prototype.ready = function() {
      return this.ok();
    };

    return DelayedSyncAnimation;

  })();

  exports = this;

  exports.DelayedOp = DelayedOp;

  exports.OneOp = OneOp;

  exports.DelayedSyncAnimation = DelayedSyncAnimation;

  window.debug = false;

  window.log = function() {
    var stuff;
    stuff = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (window.debug) {
      return console.log(stuff);
    }
  };

  Nimbus.one_time_sync = false;

  Nimbus.keys = function(item) {
    var key, keys, value;
    keys = [];
    for (key in item) {
      value = item[key];
      keys.push(key);
    }
    return keys;
  };

  Nimbus.Model.general_sync = {
    cloudcache: {},
    create_object_dictionary: function() {
      var dict, obj, _i, _len, _ref;
      dict = {};
      log("object:", this);
      _ref = this.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        dict[obj.id] = obj;
      }
      return dict;
    },
    sync_model_base_algo: function() {
      var cloud, cloud_set, cloud_time, d_array, deleted_set, dlist, eq, id, local, local_item, local_set, local_time, utc, utl, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      if (!navigator.onLine || this.is_cloud_available === false) {
        return;
      }
      log("#ONE TIME SYNC ALGO RUNNING", this.name);
      Nimbus.one_time_sync = true;
      Nimbus.currently_syncing = true;
      local = this.create_object_dictionary();
      cloud = this.cloudcache;
      local_set = new Set(Nimbus.keys(local));
      cloud_set = new Set(Nimbus.keys(cloud));
      log("local_set", local_set);
      log("cloud_set", cloud_set);
      d_array = [];
      _ref = this.DeletionStorage.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dlist = _ref[_i];
        this.delete_from_cloud(dlist.id);
        d_array.push(dlist.id);
        dlist.destroy();
      }
      deleted_set = new Set(d_array);
      log("deleted set", deleted_set);
      log("#the set of ids that are there locally but not there on the cloud", local_set.difference(cloud_set)._set);
      _ref1 = (local_set.difference(cloud_set)._set);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        local_item = local[id];
        if ((local_item["synced"] != null) && local_item.synced) {
          log("id for deletion", id);
          local[id].destroy();
        } else {
          this.add_to_cloud(local_item);
        }
      }
      log("#the set of ids that are there on the cloud but not there locally minus deletions", cloud_set.difference(local_set).difference(deleted_set)._set);
      _ref2 = (cloud_set.difference(local_set).difference(deleted_set)._set);
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        id = _ref2[_k];
        this.add_from_cloud(id);
      }
      log("#the set of ids that are there in the cloud and locally", cloud_set.intersection(local_set)._set);
      utc = [];
      utl = [];
      eq = [];
      _ref3 = (cloud_set.intersection(local_set)._set);
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        id = _ref3[_l];
        local_time = new Date(local[id].time);
        cloud_time = new Date(cloud[id].time);
        log("local_time", local_time.toString());
        log("cloud_time", cloud_time.toString());
        if (local_time - cloud_time === 0) {
          log("equal time stamp do nothin", cloud[id].title);
          eq.push(id);
        } else if (local_time - cloud_time > 0) {
          this.update_to_cloud(local[id]);
          utc.push(id);
        } else {
          this.update_to_local(local[id]);
          utl.push(id);
        }
      }
      Nimbus.currently_syncing = false;
      Nimbus.one_time_sync = false;
      log("updated to cloud", utc.length, utc);
      log("updated to local", utl.length, utl);
      return log("equal timestamp", eq.length, eq);
    },
    real_time_sync: function(record, method, e) {
      var d, syncable;
      log("method", method);
      log("record", record);
      this.saveLocal(record, method);
      if (Nimbus.currently_syncing) {
        return true;
      } else {
        if (method === "update") {
          this.records[record.id].time = new Date().toString();
        }
      }
      syncable = navigator.onLine && (localStorage["state"] === "Working" || Nimbus.Client.GDrive.check_auth());
      if (!syncable) {
        console.log("syncing is not setup correctly or the instance is not online");
        return true;
      }
      switch (method) {
        case "destroy":
          if (record.synced) {
            if (syncable) {
              log("deletion in cloud");
              return this.delete_from_cloud(record.id);
            } else {
              d = Deletion.init({
                id: record.id
              });
              return d.save();
            }
          }
          break;
        case "create":
          return this.add_to_cloud(record, function() {});
        case "update":
          return this.update_to_cloud(record, function() {});
        case "read":
          return this.update_to_local(record, function() {});
        default:
          return log("REAL TIME SYNCING FAILED, THIS METHOD NOT IMPLEMENTED");
      }
    },
    delta_update: function() {
      var change;
      return change = this.get_delta;
    }
  };

  Nimbus.Model.Local = {
    classname: "Nimbus.Model.Local",
    extended: function() {
      this.sync(this.proxy(this.saveLocal));
      return this.fetch(this.proxy(this.loadLocal));
    },
    async_doc_setup: function() {},
    saveLocal: function(record, method) {},
    loadLocal: function(callback) {}
  };

  Nimbus.Model.LocalSync = {
    classname: "Nimbus.Model.LocalSync",
    extended: function() {
      this.sync(this.proxy(this.saveLocal));
      return this.fetch(this.proxy(this.loadLocal));
    },
    saveLocal: function() {
      var result;
      result = JSON.stringify(this);
      return localStorage[this.name] = result;
    },
    loadLocal: function(callback) {
      var result;
      result = localStorage[this.name];
      if (!result) {
        return;
      }
      result = JSON.parse(result);
      this.refresh(result);
      if (callback != null) {
        return callback();
      }
    }
  };

  Nimbus.Model.Dropbox = {
    cloudcache: {},
    last_hash: "",
    hash: "",
    toCloudStructure: function(object) {
      log("local to cloud structure");
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return value;
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      log("add to cloud", object.name);
      return Nimbus.Client.Dropbox.putFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), this.toCloudStructure(object), function(resp) {
        log(object.name, "finished being added to cloud");
        log("resp", resp);
        Nimbus.currently_syncing = true;
        object.time = resp.modified;
        object.synced = true;
        object.save();
        Nimbus.currently_syncing = false;
        if (callback != null) {
          return callback(resp);
        }
      });
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id);
      log("delete route", ("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"));
      return Nimbus.Client.Dropbox.deletePath(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"), function() {
        log("finished delete from cloud", object_id);
        if (callback != null) {
          return callback();
        }
      });
    },
    update_to_cloud: function(object, callback) {
      log("updated to cloud", object.name);
      return Nimbus.Client.Dropbox.putFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), this.toCloudStructure(object), function(resp) {
        log(object.name, "finished being updated to cloud");
        Nimbus.currently_syncing = true;
        object.time = resp.modified;
        object.synced = true;
        object.save();
        Nimbus.currently_syncing = false;
        if (callback != null) {
          return callback(resp);
        }
      });
    },
    add_from_cloud: function(object_id, callback) {
      log("add from cloud", object_id);
      return Nimbus.Client.Dropbox.getFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object_id + ".txt"), (function(_this) {
        return function(data) {
          var converted, x;
          log("cloud read data", data);
          Nimbus.currently_syncing = true;
          converted = _this.fromCloudStructure(data);
          x = _this.init(converted);
          x.synced = true;
          x.time = _this.cloudcache[object_id].time;
          x.save();
          Nimbus.currently_syncing = false;
          if (callback != null) {
            return callback(data);
          }
        };
      })(this));
    },
    update_to_local: function(object, callback) {
      log("update to local", object.name);
      return Nimbus.Client.Dropbox.getFileContents(("/" + Nimbus.Auth.app_name) + ("/" + this.name + "/" + object.id + ".txt"), (function(_this) {
        return function(data) {
          var converted, x;
          log("cloud read data", data);
          Nimbus.currently_syncing = true;
          converted = _this.fromCloudStructure(data);
          x = _this.find(object.id);
          converted.time = _this.cloudcache[object.id].time;
          x.updateAttributes(converted);
          return Nimbus.currently_syncing = false;
        };
      })(this));
    },
    sync_all: function(cb) {
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      Nimbus.current_syncing = new DelayedOp((function(_this) {
        return function() {
          log("call back sync called");
          Nimbus.current_syncing = new DelayedOp(function() {
            Nimbus.current_syncing = null;
            if (cb != null) {
              return cb();
            }
          });
          _this.sync_model_base_algo();
          return Nimbus.current_syncing.ready();
        };
      })(this));
      this.load_all_from_cloud();
      return Nimbus.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var error;
      log("loads all the data from the cloud locally, probably not feasible with dropbox and changes need to happen");
      this.cloudcache = {};
      try {
        return Nimbus.Client.Dropbox.getMetadataList("/" + Nimbus.Auth.app_name + "/" + this.name, (function(_this) {
          return function(data) {
            var id, title, x, _i, _len, _ref;
            log("call back load called");
            log("data", data);
            _ref = data.contents;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              x = _ref[_i];
              title = x.path;
              id = title.replace(("/" + Nimbus.Auth.app_name + "/") + ("" + _this.name + "/"), "").replace(".txt", "");
              _this.cloudcache[id] = {
                id: id,
                time: x.modified
              };
            }
            return _this.is_cloud_available = true;
          };
        })(this), (function(_this) {
          return function(error) {
            console.log("ERROR: error called for metadataList, folder should be created");
            _this.is_cloud_available = false;
            Nimbus.Client.Dropbox.createFolder("/" + Nimbus.Auth.app_name + "/" + _this.name, function(data) {
              return log("call back create folder called", data);
            });
            return _this.cloudcache = {};
          };
        })(this));
      } catch (_error) {
        error = _error;
        _this.is_cloud_available = false;
        return log("trying to get the folder failed, probably cuz it don't exist", error);
      }
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    }
  };

  Nimbus.Auth.Dropbox_auth = {
    authenticate_dropbox: function() {
      localStorage["key"] = this.key;
      localStorage["secret"] = this.secret;
      localStorage["state"] = "Auth";
      return Nimbus.Client.Dropbox.get_request_token(this.key, this.secret, Nimbus.Client.Dropbox.authorize_token);
    },
    initialize_dropbox: function() {
      log("initialization called");
      if (location.protocol === "chrome-extension:") {
        log("Chrome edition authentication");
        chrome.tabs.onUpdated.addListener(function(tabId, changeInfo, tab) {
          if (tab.title === "API Request Authorized") {
            chrome.tabs.remove(tabId);
            return Nimbus.Client.Dropbox.get_access_token(function(data) {
              localStorage["state"] = "Working";
              if (Nimbus.Auth.authorized_callback != null) {
                Nimbus.Auth.authorized_callback();
              }
              Nimbus.Auth.app_ready_func();
              console.log("NimbusBase is working! Chrome edition.");
              return Nimbus.track.google.registered_user();
            });
          }
        });
      }
      if ((localStorage["state"] != null) && localStorage["state"] === "Auth") {
        return Nimbus.Client.Dropbox.get_access_token(function(data) {
          localStorage["state"] = "Working";
          if (Nimbus.Auth.authorized_callback != null) {
            Nimbus.Auth.authorized_callback();
          }
          Nimbus.Auth.app_ready_func();
          console.log("NimbusBase is working!");
          return Nimbus.track.google.registered_user();
        });
      } else {
        return Nimbus.Auth.app_ready_func();
      }
    },
    dropbox_authorized: function() {
      if (Nimbus.Auth.service === "Dropbox") {
        if (localStorage["state"] === "Working") {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    },
    logout_dropbox: function(callback) {
      var k, v, _ref;
      localStorage.clear();
      if (Nimbus.dictModel != null) {
        _ref = Nimbus.dictModel;
        for (k in _ref) {
          v = _ref[k];
          v.records = {};
        }
      }
      if (this.sync_services != null) {
        Nimbus.Auth.setup(this.sync_services);
      }
      if (callback != null) {
        return callback();
      }
    }
  };

  REALTIME_MIMETYPE = 'application/vnd.google-apps.drive-sdk';

  realTimeEvents = {};

  Nimbus.Model.Realtime = {
    cloudcache: {},
    callback: [],
    toCloudStructure: function(object) {
      log("local to cloud structure");
      object["type"] = this.name;
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return JSON.parse(value);
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      var content;
      log("add to cloud", object);
      Nimbus.currently_syncing = true;
      object.time = new Date().toString();
      object.type = this.name;
      object.synced = true;
      object.save();
      Nimbus.currently_syncing = false;
      content = this.toCloudStructure(object);
      return Nimbus.realtime.todo.set(object.id, content);
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id, Nimbus.realtime.todo.has(object_id));
      if (Nimbus.realtime.todo.has(object_id)) {
        return Nimbus.realtime.todo["delete"](object_id);
      }
    },
    update_to_cloud: function(object, callback) {
      var content;
      log("updated to cloud", object.id);
      content = this.toCloudStructure(object);
      return Nimbus.realtime.todo.set(object.id, content);
    },
    add_from_cloud: function(object_id, callback) {
      var converted, data, x;
      log("add from cloud GDrive", object_id);
      data = Nimbus.realtime.todo.get(object_id);
      Nimbus.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return Nimbus.currently_syncing = false;
    },
    update_to_local: function(object, callback) {
      var converted, data, x;
      log("update to local", object);
      data = Nimbus.realtime.todo.get(object.id);
      Nimbus.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return Nimbus.currently_syncing = false;
    },
    sync_all: function(cb) {
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      this.load_all_from_cloud();
      this.sync_model_base_algo();
      Nimbus.current_syncing = new DelayedOp((function(_this) {
        return function() {
          log("call back sync called");
          Nimbus.current_syncing = new DelayedOp(function() {
            Nimbus.current_syncing = null;
            if (cb != null) {
              return cb();
            }
          });
          _this.sync_model_base_algo();
          return Nimbus.current_syncing.ready();
        };
      })(this));
      this.load_all_from_cloud();
      return Nimbus.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var content, x, _i, _len, _ref, _results;
      log("loads all the data from the cloud locally");
      this.cloudcache = {};
      _ref = Nimbus.realtime.todo.keys();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        content = this.fromCloudStructure(Nimbus.realtime.todo.get(x));
        if (content.type === this.name) {
          _results.push(this.cloudcache[x] = content);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    add_realtime_callback: function(callback) {
      return log("filler");
    },
    process_callback_chain: function(mode, obj, isLocal) {
      var handler, index, _ref;
      log("filler");
      _ref = realTimeEvents[this.name];
      for (index in _ref) {
        handler = _ref[index];
        handler(mode, obj, isLocal);
      }
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    },
    onUpdate: function(callback) {
      if (!realTimeEvents[this.name]) {
        realTimeEvents[this.name] = [];
      }
      return realTimeEvents[this.name].push(callback);
    }
  };


  /* initialization and model linking code */

  Nimbus.realtime.initializeModel = function(model) {
    var field;
    log("model initialization", model);
    field = model.createMap({});
    return model.getRoot().set("todo", field);
  };

  Nimbus.realtime.onFileLoaded = function(doc) {
    var process_event, todo;
    log("file loaded", doc);
    Nimbus.realtime.doc = doc;
    process_event = function(event) {
      var a, current_event, model, obj;
      log("PROCESS EVENT");
      log(event);
      current_event = "NONE";
      if (event.oldValue != null) {
        obj = JSON.parse(event.oldValue);
      }
      if (event.newValue != null) {
        obj = JSON.parse(event.newValue);
      }
      model = Nimbus.dictModel[obj.type];
      if (event.oldValue === null) {
        log("add event");
        model.add_from_cloud(obj.id);
        current_event = "CREATE";
      } else if (event.newValue === null) {
        log("delete event");
        Nimbus.currently_syncing = true;
        if (model.exists(obj.id)) {
          a = model.find(obj.id);
          a.destroy();
        }
        Nimbus.currently_syncing = false;
        current_event = "DELETE";
      } else {
        log("changing the data inside a entry event");
        model.update_to_local(obj);
        current_event = "UPDATE";
      }
      model.process_callback_chain(current_event, obj, event.isLocal);
      log("EVENT: ", current_event, " OBJ: ", obj);
      if (window.realtime_update_handler != null) {
        return Nimbus.realtime.realtime_update_handler(current_event, obj, event.isLocal);
      }
    };
    todo = doc.getModel().getRoot().get("todo");
    Nimbus.realtime.todo = todo;
    if (Nimbus.realtime.real_time_callback != null) {
      Nimbus.realtime.real_time_callback();
    }
    return todo.addEventListener(gapi.drive.realtime.EventType.VALUE_CHANGED, process_event);
  };

  Nimbus.realtime.create_share_client = function() {
    var share_client;
    share_client = new gapi.drive.share.ShareClient(Nimbus.Auth.app_id);
    share_client.setItemIds(Nimbus.realtime.c_file.id);
    share_client.showSettingsDialog();
    return Nimbus.realtime.share_client = share_client;
  };

  Nimbus.realtime.handleErrors = handleErrors = function(e) {
    if (e.type === gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED) {
      return gapi.auth.authorize({
        client_id: Nimbus.Auth.key,
        scope: Nimbus.Auth.scope,
        immediate: true,
        authuser: localStorage.authuser || 0
      }, function(data) {
        return console.log('authorize the app after error');
      });
    } else if (e.type === gapi.drive.realtime.ErrorType.CLIENT_ERROR) {
      return alert("An Error happened: " + e.message);
    } else if (e.type === gapi.drive.realtime.ErrorType.NOT_FOUND) {
      return alert("The file was not found. It does not exist or you do not have read access to the file.");
    }
  };

  Nimbus.realtime.startRealtime = function(callback) {
    var action_for_realtime, current_user_account;
    current_user_account = Nimbus.Share.get_user_email();
    if (!localStorage.current_user_account || localStorage.current_user_account !== current_user_account) {
      delete localStorage.last_opened_workspace;
    }
    localStorage.current_user_account = current_user_account;
    if (callback != null) {
      Nimbus.realtime.real_time_callback = callback;
    }
    action_for_realtime = function() {
      return Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.drive-sdk." + Nimbus.Auth.app_id + "'", function(data) {
        var c_file, i, index, workspace, x, _ref;
        console.log("drive apps", data);
        Nimbus.realtime.app_files = data.items;
        i = [];
        workspace = 0;
        _ref = data.items;
        for (index in _ref) {
          x = _ref[index];
          log(x.mimeType);
          if (x.mimeType.indexOf("application/vnd.google-apps.drive-sdk") >= 0) {
            if (localStorage.last_opened_workspace && x.id === localStorage.last_opened_workspace) {
              workspace = index;
            }
            i.push(x);
          }
        }
        log("index", i);
        if (i.length > 0) {
          log("file there");
          if (workspace === 0) {
            delete localStorage.last_opened_workspace;
          }
          c_file = i[workspace];
          Nimbus.realtime.c_file = c_file;
          return gapi.drive.realtime.load(c_file.id, Nimbus.realtime.onFileLoaded, Nimbus.realtime.initializeModel, Nimbus.realtime.handleErrors);
        } else {
          log("file not there");
          Nimbus.Client.GDrive.insertFile("", Nimbus.Auth.app_name, 'application/vnd.google-apps.drive-sdk', null, function(data) {
            log("finished insertFile", data);
            Nimbus.realtime.c_file = data;
            Nimbus.realtime.app_files.push(data);
            return gapi.drive.realtime.load(data.id, Nimbus.realtime.onFileLoaded, Nimbus.realtime.initializeModel, Nimbus.realtime.handleErrors);
          });
          return log("need to create file for app");
        }
      });
    };
    if (Nimbus.gapi_loaded) {
      action_for_realtime();
    } else {
      Nimbus.gapi_loaded_callback = action_for_realtime;
    }
  };

  Nimbus.realtime.load_new_file = function(file_id, callback, exception_handle) {
    if (callback != null) {
      Nimbus.realtime.real_time_callback = callback;
    }
    return Nimbus.Share.getFile(file_id, function(data) {
      Nimbus.realtime.c_file = data;
      if (!data.id) {
        return;
      }
      if (exception_handle && exception_handle instanceof Function) {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, exception_handle);
      } else {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, handleErrors);
      }
    });
  };

  Nimbus.Client.Dropbox = {
    get_request_token: function(key, secret, callback) {
      var header, xhr;
      xhr = new XMLHttpRequest();
      xhr.open("POST", "https://api.dropbox.com/1/oauth/request_token", true);
      header = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + key + '",oauth_signature="' + secret + '&"';
      log(header);
      xhr.setRequestHeader("Authorization", header);
      xhr.onreadystatechange = function() {
        var data, i, k, pair, pairs, request_token, result, v, _i, _len;
        if (this.readyState === 4) {
          if (this.status === 200) {
            data = this.response;
            log(data);
            pairs = data.split(/&/);
            request_token = {};
            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
              i = pairs[_i];
              pair = i.split(RegExp("="), 2);
              request_token[pair[0]] = pair[1];
            }
            log("Token result", request_token);
            for (k in request_token) {
              v = request_token[k];
              localStorage[k] = v;
            }
            window.request_token = request_token;
            if (callback != null) {
              return callback(request_token);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            return error(result, this.status, this);
          }
        }
      };
      return xhr.send();
    },
    authorize_token: function(request_token) {
      var auth_url, ref, return_url;
      log("authorize url", document.URL);
      if (document.URL.slice(0, 4) === "file" && (typeof cordova !== "undefined" && cordova !== null)) {
        log("Phonegap login");
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        ref = window.open(auth_url, '_blank', 'location=yes');
        window.ref = ref;
        window.auth_count = 0;
        ref.addEventListener('loadstop', function(event) {
          console.log(event);
          console.log("event", event.url.indexOf("https://www.dropbox.com/1/oauth/authorize"));
          if (event.url.indexOf("https://www.dropbox.com/1/oauth/authorize") >= 0) {
            window.auth_count = window.auth_count + 1;
            if (window.auth_count === 2) {
              Nimbus.Auth.Dropbox_auth.initialize_dropbox();
              return window.ref.close();
            }
          }
        });
        return ref.addEventListener('exit', function(event) {
          return Nimbus.Auth.logout_dropbox();
        });
      } else if (document.URL.slice(0, 4) === "http") {
        return_url = "&oauth_callback=" + encodeURIComponent(document.URL);
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token + return_url;
        return location.replace(auth_url);
      } else if (document.URL.slice(0, 6) === "chrome") {
        log("chrome app!");
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        return chrome.tabs.create({
          "url": auth_url,
          "selected": true
        }, function(tab) {
          return log("tab created", tab.id);
        });
      } else {
        auth_url = "https://www.dropbox.com/1/oauth/authorize?oauth_token=" + request_token.oauth_token;
        return location.replace(auth_url);
      }
    },
    get_access_token: function(callback) {
      var auth_string, oauth_token, oauth_token_secret, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open("POST", "https://api.dropbox.com/1/oauth/access_token", true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var access_token, data, i, k, pair, pairs, result, v, _i, _len;
        if (this.readyState === 4) {
          if (this.status === 200) {
            data = this.response;
            log(data);
            pairs = data.split(/&/);
            access_token = {};
            for (_i = 0, _len = pairs.length; _i < _len; _i++) {
              i = pairs[_i];
              pair = i.split(RegExp("="), 2);
              access_token[pair[0]] = pair[1];
            }
            log("Access result", access_token);
            for (k in access_token) {
              v = access_token[k];
              localStorage[k] = v;
            }
            window.access_token = access_token;
            if (callback != null) {
              return callback(access_token);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            return log(result, this.status, this);
          }
        }
      };
      return xhr.send();
    },
    send_request: function(method, url, body, success, failure) {
      var auth_string, key, oauth_token, oauth_token_secret, pList, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var result;
        if (this.readyState === 4) {
          if (this.status === 200) {
            result = this.response;
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log("REQUEST RESULT", result);
            if (success != null) {
              success(result);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log(result, this.status, this);
            if (failure != null) {
              failure(result);
            }
          }
          if (Nimbus.current_syncing != null) {
            return Nimbus.current_syncing.ok();
          }
        }
      };
      if (method === "POST") {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        if (body) {
          pList = [];
          for (key in body) {
            pList.push(encodeURIComponent(key) + "=" + encodeURIComponent(body[key]));
          }
          body = (pList.length > 0 ? pList.join("&").replace(/%20/g, "+") : null);
        }
        log(body);
      }
      log("send request params", method, url, body, success, failure);
      if (Nimbus.current_syncing != null) {
        Nimbus.current_syncing.wait();
      }
      xhr.send(body);
      return window.xhr = xhr;
    },
    send_request_without_delay: function(method, url, body, success, failure) {
      var auth_string, key, oauth_token, oauth_token_secret, pList, xhr;
      oauth_token = localStorage["oauth_token"];
      oauth_token_secret = localStorage["oauth_token_secret"];
      auth_string = 'OAuth oauth_version="1.0",oauth_signature_method="PLAINTEXT",oauth_consumer_key="' + Nimbus.Auth.key + '",oauth_token="' + oauth_token + '",oauth_signature="' + Nimbus.Auth.secret + "&" + oauth_token_secret + '"';
      log("auth_string:", auth_string);
      xhr = new XMLHttpRequest();
      xhr.open(method, url, true);
      xhr.setRequestHeader("Authorization", auth_string);
      xhr.onreadystatechange = function() {
        var result;
        if (this.readyState === 4) {
          if (this.status === 200) {
            result = this.response;
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log("REQUEST RESULT", result);
            if (success != null) {
              return success(result);
            }
          } else {
            try {
              result = JSON.parse(result);
            } catch (_error) {}
            log(result, this.status, this);
            if (failure != null) {
              return failure(result);
            }
          }
        }
      };
      if (method === "POST") {
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        if (body) {
          pList = [];
          for (key in body) {
            pList.push(encodeURIComponent(key) + "=" + encodeURIComponent(body[key]));
          }
          body = (pList.length > 0 ? pList.join("&").replace(/%20/g, "+") : null);
        }
        log(body);
      }
      log("send request params", method, url, body, success, failure);
      return xhr.send(body);
    },
    putFileContents: function(path, content, success, error) {
      log("putFileContents");
      return Nimbus.Client.Dropbox.send_request("PUT", "https://api-content.dropbox.com/1/files_put/sandbox" + path, content, success, error);
    },
    createFolder: function(path, success, error) {
      log("createFolder");
      return Nimbus.Client.Dropbox.send_request("POST", "https://api.dropbox.com/1/fileops/create_folder", {
        root: 'sandbox',
        path: path
      }, success, error);
    },
    deletePath: function(path, success, error) {
      log("deletePath");
      return Nimbus.Client.Dropbox.send_request("POST", "https://api.dropbox.com/1/fileops/delete", {
        root: 'sandbox',
        path: path
      }, success, error);
    },
    getFileContents: function(path, success, error) {
      log("getFileContents");
      return Nimbus.Client.Dropbox.send_request("GET", "https://api-content.dropbox.com/1/files/sandbox" + path, "", success, error);
    },
    getMetadataList: function(path, success, error) {
      log("getMetadataList");
      return Nimbus.Client.Dropbox.send_request("GET", "https://api.dropbox.com/1/metadata/sandbox" + path, "", success, error);
    },
    getAccountInfo: function(success, error) {
      log("getAccountInfo");
      return Nimbus.Client.Dropbox.send_request_without_delay("GET", "https://api.dropbox.com/1/account/info", "", success, error);
    }
  };

  window.client = null;

  Nimbus.Client.Dropbox.Binary = {
    binary_setup: function() {
      return window.binary = Nimbus.Model.setup("binary", ["name", "path", "copied", "directlink", "sharelink", "expiration"]);
    },
    initialize_client: function() {
      log("initializing second client");
      if (Nimbus.Auth.key != null) {
        if (window.client == null) {
          window.client = new Dropbox.Client({
            key: Nimbus.Auth.key,
            secret: Nimbus.Auth.secret,
            sandbox: true
          });
          return window.client.oauth.setToken(localStorage["oauth_token"], localStorage["oauth_token_secret"]);
        } else {

        }
      } else {
        return log("can't upload file with no dropbox credentials");
      }
    },
    upload_blob: function(blob, name, callback) {
      var come_back, new_file;
      log("upload new blob");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        new_file = binary.create({
          name: name,
          copied: false
        });
        come_back = function(error, stat) {
          console.log("wrote file to cloud");
          console.log(error, stat);
          new_file.copied = true;
          new_file.path = stat.path;
          new_file.save();
          if (callback != null) {
            return callback(new_file);
          }
        };
        log("file name", name);
        return window.client.writeFile(name, blob, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    upload_file: function(file, callback) {
      var come_back, new_file;
      log("upload new file");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        new_file = binary.create({
          name: file.name,
          copied: false
        });
        come_back = function(error, stat) {
          console.log("wrote file to cloud");
          console.log(error, stat);
          new_file.copied = true;
          new_file.path = stat.path;
          new_file.save();
          if (callback != null) {
            return callback(new_file);
          }
        };
        log("file name", file.name);
        return window.client.writeFile(file.name, file, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    read_file: function(binary, callback) {
      var come_back;
      log("read a binary file from the server");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, data, stat) {
          console.log(error, data, stat);
          return callback(data);
        };
        return window.client.readFile(binary.path, {
          "blob": true
        }, come_back);
      } else {
        return log("client won't initialize");
      }
    },
    share_link: function(binary, callback) {
      var come_back;
      log("get the share link");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, data) {
          console.log(error, data);
          binary.sharelink = data.url;
          binary.save();
          return callback(data);
        };
        console.log(binary.path);
        return window.client.makeUrl(binary.path, {}, come_back);
      }
    },
    direct_link: function(binary, callback) {
      var come_back;
      log("get the share link");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        if ((binary.directlink != null) && new Date(binary.expiration) > new Date()) {
          return callback({
            "url": binary.directlink,
            "expiresAt": binary.expiration
          });
        } else {
          come_back = function(error, url) {
            console.log(error, url);
            binary.directlink = url.url;
            binary.expiration = url.expiresAt.toString();
            binary.save();
            return callback(url);
          };
          return window.client.makeUrl(binary.path, {
            'download': true,
            'downloadHack': true
          }, come_back);
        }
      }
    },
    delete_file: function(binary) {
      var come_back;
      log("delete file");
      Nimbus.Client.Dropbox.Binary.initialize_client();
      if (window.client != null) {
        come_back = function(error, stat) {
          return binary.destroy();
        };
        return window.client.remove(binary.path, come_back);
      } else {
        return log("client won't initialize");
      }
    }
  };

  Nimbus.Client.GDrive = {
    check_auth: function() {
      var token;
      log("checking if this is authenticated");
      if (location.protocol === "chrome-extension:") {
        if ((typeof gapi !== "undefined" && gapi !== null) && (gapi.auth != null) && gapi.auth.getToken() === null && (Nimbus.realtime.todo != null)) {
          token = Nimbus.Auth.GDrive.getLocalOauth2Token();
          if ((token == null) || Nimbus.Auth.GDrive.isTokenExpires(token)) {
            return false;
          } else {
            gapi.auth.setToken(token);
            return true;
          }
        }
      }
      return (typeof gapi !== "undefined" && gapi !== null) && (gapi.auth != null) && gapi.auth.getToken() !== null && Object.keys(gapi.auth.getToken()).length !== 0 && (Nimbus.realtime.todo != null);
    },
    authorize: function(client_id, scopes, callback) {
      log("authorized called");
      return gapi.auth.authorize({
        client_id: client_id,
        scope: scopes,
        immediate: false,
        authuser: localStorage.authuser || 0,
        prompt: 'select_account'
      }, callback);
    },
    insertFile: function(content, title, contentType, parent, callback, properties) {
      var base64Data, boundary, close_delim, delimiter, metadata, multipartRequestBody, params;
      log("putFileContents");
      boundary = "-------314159265358979323846";
      delimiter = "\r\n--" + boundary + "\r\n";
      close_delim = "\r\n--" + boundary + "--";
      base64Data = btoa(content);
      metadata = {
        title: title,
        mimeType: contentType
      };
      if (parent != null) {
        metadata['parents'] = [
          {
            "kind": "drive#fileLink",
            "id": parent
          }
        ];
      }
      if (properties) {
        metadata.properties = properties;
      }
      multipartRequestBody = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: " + contentType + "\r\n" + 'Content-Transfer-Encoding: base64\r\n' + "\r\n" + base64Data + close_delim;
      log("MULTI: ", multipartRequestBody);
      if (!callback) {
        callback = function(file) {
          return log("Update Complete ", file);
        };
      }
      if (content) {
        params = {
          path: "/upload/drive/v2/files",
          method: "POST",
          params: {
            uploadType: "multipart"
          },
          headers: {
            "Content-Type": "multipart/mixed; boundary=\"" + boundary + "\""
          },
          body: multipartRequestBody
        };
      } else {
        params = {
          path: "/drive/v2/files",
          method: "POST",
          body: {
            'title': title,
            'mimeType': contentType
          }
        };
        if (properties) {
          params.body.properties = properties;
        }
      }
      return this.make_request(params, callback);
    },
    deleteFile: function(file_id, callback) {
      var params;
      log("deletePath");
      if (!callback) {
        callback = (function(_this) {
          return function(resp) {
            var params;
            params = {
              path: "/drive/v2/files/" + file_id,
              method: "DELETE"
            };
            _this.make_request(params, function(data) {
              return log("delete complete", data);
            });
            return log("Delete Complete ", resp);
          };
        })(this);
      }
      params = {
        path: "/drive/v2/files/" + file_id + "/trash",
        method: "POST"
      };
      return this.make_request(params, callback);
    },
    getFile: function(file_id, callback) {
      var params;
      log("getFileContents");
      if (!callback) {
        callback = function(resp) {
          return log("Read Complete ", resp);
        };
      }
      params = {
        path: "/drive/v2/files/" + file_id,
        method: "GET"
      };
      return this.make_request(params, callback);
    },
    readFile: function(url, callback) {
      var accessToken, xhr;
      if (!callback) {
        callback = function(resp) {
          return log("Read Complete ", resp);
        };
      }
      accessToken = gapi.auth.getToken().access_token;
      xhr = new XMLHttpRequest();
      xhr.open("GET", url);
      xhr.setRequestHeader("Authorization", "Bearer " + accessToken);
      xhr.onload = function() {
        callback(xhr.responseText);
        if (Nimbus.current_syncing != null) {
          return Nimbus.current_syncing.ok();
        }
      };
      xhr.onerror = function() {
        return callback(null);
      };
      if (Nimbus.current_syncing != null) {
        Nimbus.current_syncing.wait();
      }
      return xhr.send();
    },
    updateFile: function(content, title, contentType, file_id, folder_id, callback) {
      var base64Data, boundary, close_delim, delimiter, metadata, multipartRequestBody, params;
      log("updateFileContents");
      boundary = "-------314159265358979323846";
      delimiter = "\r\n--" + boundary + "\r\n";
      close_delim = "\r\n--" + boundary + "--";
      contentType = "text/html";
      metadata = {
        mimeType: contentType
      };
      base64Data = btoa(content);
      metadata = {
        title: title,
        mimeType: contentType
      };
      multipartRequestBody = delimiter + "Content-Type: application/json\r\n\r\n" + JSON.stringify(metadata) + delimiter + "Content-Type: " + contentType + "\r\n" + 'Content-Transfer-Encoding: base64\r\n' + "\r\n" + base64Data + close_delim;
      if (!callback) {
        callback = function(file) {
          return log("Update Complete ", file);
        };
      }
      params = {
        path: "/upload/drive/v2/files/" + file_id,
        method: "PUT",
        params: {
          fileId: file_id,
          uploadType: "multipart"
        },
        headers: {
          "Content-Type": "multipart/mixed; boundary=\"" + boundary + "\""
        },
        body: multipartRequestBody
      };
      return this.make_request(params, callback);
    },
    getMetadataList: function(query, callback) {
      var params;
      log("getMetadataList");
      if (!callback) {
        callback = function(file) {
          return log("List of files", file);
        };
      }
      params = {
        path: "/drive/v2/files",
        method: "GET",
        params: {
          q: query
        }
      };
      return this.make_request(params, callback);
    },
    make_request: function(params, callback) {
      params['callback'] = function(data) {
        if (callback != null) {
          callback(data);
        }
        if (Nimbus.current_syncing != null) {
          return Nimbus.current_syncing.ok();
        }
      };
      if (Nimbus.current_syncing != null) {
        Nimbus.current_syncing.wait();
      }
      return gapi.client.request(params);
    },
    get_current_user: function(callback) {
      var params, process;
      log("get current user");
      process = (function(_this) {
        return function(file) {
          var user;
          log("About called ", file);
          user = {};
          user.name = file["user"].displayName;
          user.id = file["user"].permissionId;
          if (file["user"].picture != null) {
            user.pic = file["user"].picture.url;
          }
          if (callback != null) {
            return callback(user);
          }
        };
      })(this);
      params = {
        path: "/drive/v2/about",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    get_current_user_info: function(callback) {
      var params, process;
      log("get current user");
      process = (function(_this) {
        return function(user) {
          if (callback != null) {
            return callback(user);
          }
        };
      })(this);
      params = {
        path: "/plus/v1/people/me",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    add_share_user: function(email, callback) {
      var app_folder_id, params, process;
      log("&&& add share user");
      process = (function(_this) {
        return function(person) {
          var p;
          log("Add Share user Complete ", person);
          p = {
            id: person.id,
            email: person.emailAddress,
            name: person.name,
            role: person.role
          };
          if (person.photoLink != null) {
            p["pic"] = person.photoLink;
          }
          if (callback != null) {
            return callback(p);
          }
        };
      })(this);
      app_folder_id = Nimbus.realtime.folder['binary_files'].id;
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions",
        method: "POST",
        params: {
          fileId: app_folder_id
        },
        body: {
          role: "writer",
          type: "user",
          value: email
        }
      };
      return this.make_request(params, process);
    },
    add_share_user_real: function(email, callback, file_id) {
      var fid, params, process;
      log("&&& add share user");
      fid = file_id ? file_id : Nimbus.realtime.c_file.id;
      process = (function(_this) {
        return function(person) {
          var p;
          log("Add Share user Complete ", person);
          p = {
            id: person.id,
            email: person.emailAddress,
            name: person.name,
            role: person.role
          };
          if (person.photoLink != null) {
            p["pic"] = person.photoLink;
          }
          if (callback != null) {
            return callback(p);
          }
        };
      })(this);
      params = {
        path: "/drive/v2/files/" + fid + "/permissions",
        method: "POST",
        params: {
          fileId: fid
        },
        body: {
          role: "writer",
          type: "user",
          value: email
        }
      };
      return this.make_request(params, process);
    },
    remove_share_user: function(id, callback) {
      var app_folder_id, params;
      log("&&& remove a user from sharing this app");
      app_folder_id = Nimbus.realtime.folder['binary_files'].id;
      if (!callback) {
        callback = function(file) {
          return log("Permission Removal Complete ", file);
        };
      }
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions/" + id,
        method: "DELETE"
      };
      return this.make_request(params, callback);
    },
    remove_share_user_real: function(id, callback, file_id) {
      var params;
      log("&&& remove a user from sharing this app");
      if (!callback) {
        callback = function(file) {
          return log("Permission Removal Complete ", file);
        };
      }
      file_id = file_id ? file_id : Nimbus.realtime.c_file.id;
      params = {
        path: "/drive/v2/files/" + file_id + "/permissions/" + id,
        method: "DELETE"
      };
      return this.make_request(params, callback);
    },
    get_user_email: function() {
      var access_token, data, xhr;
      if (Nimbus.realtime.user_email != null) {
        return Nimbus.realtime.user_email;
      }
      access_token = gapi.auth.getToken().access_token;
      data = null;
      xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            return data = JSON.parse(xhr.responseText);
          } else {
            return log("get user email failed with status " + xhr.status);
          }
        }
      };
      xhr.open("GET", "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=" + access_token, false);
      xhr.send(null);
      if ((data != null ? data.email : void 0) != null) {
        Nimbus.realtime.user_email = data.email;
        return data.email;
      }
      return null;
    },
    get_shared_users_real: function(callback) {
      var params, process;
      log("&&& get shared users");
      process = (function(_this) {
        return function(file) {
          var p, perm, permissions, _i, _len, _ref;
          log("Update Complete ", file);
          permissions = [];
          _ref = file.items;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            perm = {
              id: p.id,
              name: p.name,
              role: p.role,
              email: p.emailAddress
            };
            if (p.photoLink != null) {
              perm["pic"] = p.photoLink;
            }
            permissions.push(perm);
          }
          log("permissions", permissions);
          if (callback != null) {
            return callback(permissions);
          }
        };
      })(this);
      params = {
        path: "/drive/v2/files/" + Nimbus.realtime.c_file.id + "/permissions",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    get_shared_users: function(callback) {
      var app_folder_id, params, process;
      log("&&& get shared users");
      app_folder_id = Nimbus.realtime.folder['binary_files'].id;
      process = (function(_this) {
        return function(file) {
          var p, perm, permissions, _i, _len, _ref;
          log("Update Complete ", file);
          permissions = [];
          _ref = file.items;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            perm = {
              id: p.id,
              name: p.name,
              role: p.role
            };
            if (p.photoLink != null) {
              perm["pic"] = p.photoLink;
            }
            permissions.push(perm);
          }
          log("permissions", permissions);
          if (callback != null) {
            return callback(permissions);
          }
        };
      })(this);
      params = {
        path: "/drive/v2/files/" + app_folder_id + "/permissions",
        method: "GET"
      };
      return this.make_request(params, process);
    },
    get_app_folders: function(callback) {
      log("&&& get app folders");
      return Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.folder' and title = '" + Nimbus.Auth.app_name + "'", function(data) {
        var f, folders, s, spaces, _i, _len;
        log(data);
        folders = data.items;
        spaces = [];
        if (data.items != null) {
          for (_i = 0, _len = folders.length; _i < _len; _i++) {
            f = folders[_i];
            s = {};
            s.id = f.id;
            s.owner = f.ownerNames[0];
            spaces.push(s);
          }
        }
        log(spaces);
        if (callback != null) {
          return callback(spaces);
        }
      });
    },
    switch_to_app_folder: function(id, callback) {
      log("###switch to app folder");
      Nimbus.realtime.folder = {};
      Nimbus.realtime.folder[Nimbus.Auth.app_name] = {
        "title": Nimbus.Auth.app_name,
        "id": id
      };
      Nimbus.current_syncing = new DelayedOp((function(_this) {
        return function() {
          if (callback != null) {
            return callback();
          }
        };
      })(this));
      localStorage["main_folder_id"] = id;
      Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.folder'", function(data) {
        var a, k, v, x, _i, _len, _ref, _results;
        a = data.items;
        log("###rewriting folders", a);
        for (_i = 0, _len = a.length; _i < _len; _i++) {
          x = a[_i];
          log(x);
          if (x.parents.length > 0 && (x.parents[0].id === id)) {
            Nimbus.realtime.folder[x.title] = x;
          }
        }
        if (Nimbus.dictModel != null) {
          _ref = Nimbus.dictModel;
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            _results.push(v.records = {});
          }
          return _results;
        }
      });
      return Nimbus.current_syncing.ready();
    },
    switch_to_app_file_real: function(id, callback) {
      localStorage.last_opened_workspace = id;
      Nimbus.current_syncing = new DelayedOp((function(_this) {
        return function() {
          if (callback != null) {
            return callback();
          }
        };
      })(this));
      if (window._indexdb) {
        _indexdb.allDocs({
          include_docs: true
        }, function(err, res) {
          var row, _i, _len, _ref, _results;
          if (!err) {
            _ref = res.rows;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              row = _ref[_i];
              _results.push(_indexdb.remove(row.doc, function(e, r) {
                return log('ok', e, r);
              }));
            }
            return _results;
          }
        });
      }
      Nimbus.Share.getFile(id, function(data) {
        var k, v, _ref;
        if (!data.id) {
          return;
        }
        Nimbus.realtime.c_file = data;
        if (Nimbus.dictModel != null) {
          _ref = Nimbus.dictModel;
          for (k in _ref) {
            v = _ref[k];
            v.records = {};
            if (Nimbus.Storage) {
              Nimbus.Storage[v.name] = [];
            }
          }
        }
        return gapi.drive.realtime.load(id, Nimbus.realtime.onFileLoaded, Nimbus.realtime.initializeModel, Nimbus.realtime.handleErrors);
      });
      return Nimbus.current_syncing.ready();
    },
    build_params: function(obj) {
      var k, params_arr, v;
      params_arr = (function() {
        var _results;
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })();
      return params_arr.join("&");
    },
    extract_params_from_url: function() {
      var m, params, queryString, regex;
      params = {};
      queryString = location.hash.substring(1);
      regex = /([^&=]+)=([^&]*)/g;
      while (m = regex.exec(queryString)) {
        params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
      }
      return params;
    },
    request_access_token: function() {
      var params, params_str, redirect_uri, url;
      redirect_uri = Nimbus.Auth.redirect_uri || window.location.protocol + '//' + window.location.host + window.location.pathname;
      params = {
        response_type: "token",
        client_id: Nimbus.Auth.key,
        'redirect_uri': redirect_uri,
        scope: Nimbus.Auth.scope,
        state: "gdrive_get_access_token",
        prompt: "select_account"
      };
      params_str = Nimbus.Client.GDrive.build_params(params);
      url = "https://accounts.google.com/o/oauth2/auth?" + params_str;
      return window.open(url, "_self");
    },
    request_validate_token: function(token) {
      var data, xhr;
      xhr = new XMLHttpRequest();
      data = null;
      xhr.onreadystatechange = function() {
        var _ref;
        if (xhr.readyState === 4) {
          if ((_ref = xhr.status) === 200 || _ref === 400) {
            return data = JSON.parse(xhr.responseText);
          } else {
            return log("validate access token failed with status " + xhr.status);
          }
        }
      };
      xhr.open("GET", "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=" + token, false);
      xhr.send(null);
      return data;
    },
    is_token_validate: function(token) {
      var data, result;
      result = false;
      data = this.request_validate_token(token);
      if (data == null) {
        return false;
      }
      if (!("error" in data) && (data != null ? data.audience : void 0) === Nimbus.Auth.key) {
        result = true;
      }
      return result;
    },
    handle_auth_redirected: function() {
      return typeof history.replaceState === "function" ? history.replaceState("", document.title, window.location.pathname) : void 0;
    },
    is_auth_redirected: function() {
      var params;
      params = this.extract_params_from_url();
      if (params.state === "gdrive_get_access_token" && "token_type" in params && params.token_type === "Bearer") {
        if (params.authuser) {
          localStorage.authuser = params.authuser;
        }
        return true;
      }
      return false;
    }
  };

  Nimbus.Client.GDrive.Binary = {
    binary_setup: function() {
      return window.binary = Nimbus.Model.setup("binary", ["name", "path", "copied", "directlink", "sharelink", "expiration", "file_id"]);
    },
    initialize_client: function(run) {
      log("initializing client");
      if ((Nimbus.Auth.key != null) && (Nimbus.Auth.scope != null)) {
        if (!Nimbus.Client.GDrive.check_auth()) {
          return Nimbus.Client.GDrive.authorize(Nimbus.Auth.key, Nimbus.Auth.scope, function() {
            log("GDrive authorized");
            if (run) {
              return run();
            }
          });
        } else {
          if (run) {
            return run();
          }
        }
      } else {
        return log("can't upload file with no GDrive credentials");
      }
    },
    upload_blob: function(blob, name, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var reader;
        log("upload new blob");
        reader = new FileReader();
        reader.readAsBinaryString(blob);
        return reader.onload = function() {
          var come_back, content, contentType, new_file, parent;
          content = reader.result;
          contentType = blob.type || 'application/octet-stream';
          parent = Nimbus.realtime.folder["binary_files"].id;
          new_file = binary.create({
            'name': name
          });
          come_back = function(file) {
            console.log("upload file to cloud");
            console.log(file);
            new_file.copied = true;
            new_file.file_id = file.id;
            new_file.directlink = file.webContentLink;
            new_file.save();
            if (callback != null) {
              return callback(new_file);
            }
          };
          return Nimbus.Client.GDrive.insertFile(content, name, contentType, parent, come_back);
        };
      });
    },
    upload_file: function(file, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var reader;
        log("upload new file");
        reader = new FileReader();
        reader.readAsBinaryString(file);
        return reader.onload = function() {
          var come_back, content, contentType, name, new_file, parent;
          name = file.name;
          content = reader.result;
          contentType = file.type || 'application/octet-stream';
          parent = Nimbus.realtime.folder["binary_files"].id;
          new_file = binary.create({
            'name': name
          });
          come_back = function(file) {
            console.log("upload file to cloud");
            console.log(file);
            new_file.copied = true;
            new_file.file_id = file.id;
            new_file.directlink = file.webContentLink;
            new_file.save();
            new_file._file = file;
            if (callback != null) {
              return callback(new_file);
            }
          };
          return Nimbus.Client.GDrive.insertFile(content, name, contentType, parent, come_back);
        };
      });
    },
    read_file: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        var param;
        log("read metadata of a file from the server");
        param = {
          path: "/drive/v2/files/" + binary.file_id
        };
        return Nimbus.Client.GDrive.make_request(param, function(data) {
          console.log(data);
          if (callback) {
            return callback(data);
          }
        });
      });
    },
    share_link: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("get the share link");
        if (callback) {
          return callback("");
        }
      });
    },
    direct_link: function(binary, callback) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("get the direct link");
        if (callback) {
          return callback(binary.directlink);
        }
      });
    },
    delete_file: function(binary) {
      return Nimbus.Client.GDrive.Binary.initialize_client(function() {
        log("delete file", binary);
        return Nimbus.Client.GDrive.deleteFile(binary.file_id, function() {
          return binary.destroy();
        });
      });
    }
  };

  window.nimbus_error = [];

  Nimbus.Model.GDrive = {
    cloudcache: {},
    last_hash: "",
    hash: "",
    toCloudStructure: function(object) {
      log("local to cloud structure");
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return JSON.parse(value);
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      var parent, parent_name;
      log("add to cloud", object);
      parent_name = object.parent.name;
      parent = Nimbus.realtime.folder[parent_name].id;
      return Nimbus.Client.GDrive.insertFile(this.toCloudStructure(object), object.id, "text/plain", parent, function(data) {
        log("logging data inserted", data);
        Nimbus.currently_syncing = true;
        object.gid = data.id;
        object.time = data.modifiedDate;
        object.synced = true;
        object.save();
        return Nimbus.currently_syncing = false;
      });
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id);
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object_id + "'", function(data) {
        var id;
        log("data", data);
        if (data.items.length > 0) {
          id = data.items[0].id;
          Nimbus.Client.GDrive.deleteFile(id);
          if (callback != null) {
            return callback();
          }
        } else {
          return log("file to be deleted not there");
        }
      });
    },
    update_to_cloud: function(object, callback) {
      var comeback, parent, parent_name, update_comback;
      log("updated to cloud", object.name);
      parent_name = object.parent.name;
      parent = Nimbus.realtime.folder[parent_name].id;
      update_comback = (function(_this) {
        return function(data) {
          log("logging data inserted", data);
          Nimbus.currently_syncing = true;
          object.time = data.modifiedDate;
          object.save();
          object.synced = true;
          return Nimbus.currently_syncing = false;
        };
      })(this);
      comeback = (function(_this) {
        return function(data) {
          var id;
          id = data.items[0].id;
          return Nimbus.Client.GDrive.updateFile(_this.toCloudStructure(object), object.id, "text/plain", id, parent, function(data) {
            log("logging data inserted", data);
            Nimbus.currently_syncing = true;
            object.time = data.modifiedDate;
            object.save();
            return Nimbus.currently_syncing = false;
          });
        };
      })(this);
      if (object.gid != null) {
        return Nimbus.Client.GDrive.updateFile(this.toCloudStructure(object), object.id, "text/plain", object.gid, parent, function(data) {
          log("logging data updated", data);
          Nimbus.currently_syncing = true;
          object.time = data.modifiedDate;
          object.save();
          return Nimbus.currently_syncing = false;
        });
      } else {
        return Nimbus.Client.GDrive.getMetadataList("title = '" + object.id + "'", comeback);
      }
    },
    add_from_cloud: function(object_id, callback) {
      var process_data;
      log("add from cloud GDrive", object_id);
      process_data = (function(_this) {
        return function(data) {
          var converted, x;
          log("cloud url data", JSON.parse(data));
          Nimbus.currently_syncing = true;
          converted = _this.fromCloudStructure(data);
          x = _this.init(converted);
          x.synced = true;
          x.time = _this.cloudcache[object_id].time;
          x.save();
          return Nimbus.currently_syncing = false;
        };
      })(this);
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object_id + "'", function(data) {
        var url;
        log("cloud read data", data);
        if ((data.items != null) && data.items.length >= 1) {
          url = data.items[0].downloadUrl;
          return Nimbus.Client.GDrive.readFile(url, process_data);
        } else {
          return log("This data is not there");
        }
      });
    },
    update_to_local: function(object, callback) {
      var process_data;
      log("update to local", object);
      process_data = (function(_this) {
        return function(data) {
          var converted, x;
          log("cloud url data", JSON.parse(data));
          Nimbus.currently_syncing = true;
          converted = _this.fromCloudStructure(data);
          x = _this.find(object.id);
          converted.time = _this.cloudcache[object.id].time;
          x.updateAttributes(converted);
          return Nimbus.currently_syncing = false;
        };
      })(this);
      return Nimbus.Client.GDrive.getMetadataList("title = '" + object.id + "'", function(data) {
        var url;
        log("cloud read data", data);
        if (data.error != null) {
          window.nimbus_error.push({
            error: data.error,
            object: object
          });
          return console.log("##ERROR writing back to local", data.error, "object: ", object);
        } else {
          if (data.items.length >= 1) {
            url = data.items[0].downloadUrl;
            return Nimbus.Client.GDrive.readFile(url, process_data);
          } else {
            return log("This data is not there");
          }
        }
      });
    },
    sync_all: function(cb) {
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      Nimbus.current_syncing = new DelayedOp((function(_this) {
        return function() {
          log("call back sync called");
          Nimbus.current_syncing = new DelayedOp(function() {
            Nimbus.current_syncing = null;
            if (cb != null) {
              return cb();
            }
          });
          _this.sync_model_base_algo();
          return Nimbus.current_syncing.ready();
        };
      })(this));
      this.load_all_from_cloud();
      return Nimbus.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var fill_cache, folder_id, object_name;
      log("loads all the data from the cloud locally");
      this.cloudcache = {};
      object_name = this.name;
      log("object name", object_name);
      if ((Nimbus.realtime.folder != null) && (Nimbus.realtime.folder[object_name] != null)) {
        folder_id = Nimbus.realtime.folder[object_name].id;
        fill_cache = (function(_this) {
          return function(data) {
            var x, _i, _len, _ref, _results;
            log("cloud read data", object_name, data);
            if (data.items != null) {
              _ref = data.items;
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                x = _ref[_i];
                _this.cloudcache[x.title] = {
                  id: x.title,
                  time: x.modifiedDate
                };
                if (x.labels.trashed) {
                  _results.push(console.log("##### this is trashed #####", x));
                } else {
                  _results.push(void 0);
                }
              }
              return _results;
            } else {
              return log("###ERROR, no return data");
            }
          };
        })(this);
        Nimbus.Client.GDrive.getMetadataList("'" + folder_id + "' in parents", fill_cache);
        return _this.is_cloud_available = true;
      } else {
        log("############################BIG ERROR no folder there for load from cloud");
        return _this.is_cloud_available = false;
      }
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    }
  };

  Nimbus.realtime.folder = null;

  Nimbus.realtime.folder_creation = new OneOp();

  Nimbus.realtime.creating = {};

  Nimbus.realtime.handle_initialization = new OneOp();

  Nimbus.realtime.gdrive_initialized = false;

  Nimbus.realtime.folder_initialize = function(callback) {
    var c_file, get_app_folder, properties, query, space_folder_name;
    c_file = Nimbus.realtime.c_file;
    space_folder_name = c_file.title + ' files';
    query = "mimeType = 'application/vnd.google-apps.folder' and properties has { key='space' and value='" + c_file.id + "' and visibility='PRIVATE' }";
    properties = [
      {
        key: 'space',
        value: c_file.id,
        visibility: 'PRIVATE'
      }
    ];
    get_app_folder = function(handle) {
      return Nimbus.Client.GDrive.getMetadataList(query, function(data) {
        if (handle) {
          return handle(data);
        }
      });
    };
    log("&&& folder initialize");
    log("Nimbus.Client.GDrive.check_auth()", Nimbus.Client.GDrive.check_auth(), "Nimbus.Auth.service", Nimbus.Auth.service);
    if (Nimbus.Client.GDrive.check_auth() && Nimbus.Auth.service === 'GDrive') {
      log("this is authenticated and a GDrive app");
      return Nimbus.Client.GDrive.getMetadataList(query, function(data) {
        var a, x, _i, _len;
        log("#data: ", data);
        Nimbus.realtime.folder = {};
        a = data.items;
        if (localStorage["main_folder_id"] != null) {
          return Nimbus.realtime.folder[Nimbus.Auth.app_name] = {
            "title": Nimbus.Auth.app_name,
            "id": localStorage["main_folder_id"]
          };
        } else if (!a.error) {
          for (_i = 0, _len = a.length; _i < _len; _i++) {
            x = a[_i];
            if (x.owners[0].permissionId === c_file.owners[0].permissionId) {
              Nimbus.realtime.folder.binary_files = x;
              break;
            }
          }
          if (Nimbus.realtime.folder["binary_files"] == null) {
            return Nimbus.Client.GDrive.insertFile("", c_file.title + ' files', "application/vnd.google-apps.folder", null, function(data) {
              log("binary_files folder data", data);
              log("binary ready callback", binary_ready_callback);
              Nimbus.realtime.folder['binary_files'] = data;
              if (Nimbus.realtime.binary_ready_callback) {
                Nimbus.realtime.binary_ready_callback();
              }
              if (callback != null) {
                return callback();
              }
            }, properties);
          } else {
            log("binary ready callback", binary_ready_callback);
            if (Nimbus.realtime.binary_ready_callback) {
              Nimbus.realtime.binary_ready_callback();
            }
            if (callback != null) {
              return callback();
            }
          }
        } else {
          return console.log('error');
        }
      });
    }
  };

  Nimbus.Auth.GDrive = {
    init_scope: function() {
      var user_email_scope, x;
      x = this.scope;
      isArray = Array.isArray || function(value) {
        return {}.toString.call(value) === '[object Array]';
      };
      user_email_scope = 'https://www.googleapis.com/auth/userinfo.email';
      if (isArray(x)) {
        if (__indexOf.call(x, user_email_scope) < 0) {
          x.push(user_email_scope);
        }
      } else {
        x = [x, user_email_scope];
      }
      if (x.indexOf('openid') === -1) {
        x.push('openid');
      }
      return this.scope = x.join(" ");
    },
    get_token_from_code: function(code) {
      var data, xhr;
      xhr = new XMLHttpRequest();
      data = "code=" + code + "&client_id=" + this.key + "&client_secret=" + this.client_secret + "&grant_type=authorization_code&redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob";
      xhr.open("POST", "https://accounts.google.com/o/oauth2/token");
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = (function(_this) {
        return function(status, response) {
          var e, result;
          if (xhr.readyState === 4) {
            try {
              result = JSON.parse(xhr.response);
              if (result["error"]) {
                return console.log('error');
              } else {
                window.plugins.childBrowser.close();
                localStorage["phonegap_token"] = JSON.stringify(result);
                localStorage["state"] = "Working";
                gapi.auth.setToken(result);
                _this.prepare_gdrive();
                return Nimbus.track.google.registered_user();
              }
            } catch (_error) {
              e = _error;
              return console.log(e);
            }
          }
        };
      })(this);
      xhr.send(data);
      return xhr;
    },
    authenticate_gdrive: function() {
      var auth_url, cb, url;
      log("this should bring up a prompt to initialize into GDrive");
      localStorage["d_key"] = this.key;
      localStorage["secret"] = this.scope;
      localStorage["state"] = "Auth";
      if (document.URL.slice(0, 4) === "file" && (typeof cordova !== "undefined" && cordova !== null)) {
        log("Phonegap google login");
        auth_url = "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=" + this.key + "&scope=" + encodeURIComponent(this.scope) + "&approval_prompt=auto&redirect_uri=urn:ietf:wg:oauth:2.0:oob";
        window.auth_url = auth_url;
        cb = window.plugins.childBrowser;
        if (cb !== null) {
          cb.onLocationChange = function(loc) {
            return locChanged(loc);
          };
          cb.onClose = function() {
            return onCloseBrowser();
          };
          cb.onOpenExternal = function() {
            return onOpenExternal();
          };
          url = auth_url + "###var sendToApp = function(_key, _val) {var iframe = document.createElement('IFRAME');iframe.setAttribute('src', _key + ':##sendToApp##' + _val);document.documentElement.appendChild(iframe);iframe.parentNode.removeChi(iframe);iframe = null;};var log=function(_mssg){sendToApp('ios-log',_mssg);}; var html = document.getElementById('code').value; log(html);";
          cb.onJSCallback = function(backStr) {
            cb.code = backStr;
            if (backStr && (backStr != null) && backStr !== "(null)") {
              cb.close();
              console.log("will get some toaken");
              return Nimbus.Auth.get_token_from_code(backStr);
            }
          };
          return cb.showWebPage(url);
        }
      } else if (location.protocol === "chrome-extension:") {
        log("chrome extension authorize");
        return this.oauth2_authorize();
      } else {
        return Nimbus.Client.GDrive.request_access_token();
      }
    },
    initialize_gdrive: function() {
      log("This part should reflect what initialization needs to be done for GDrive auth");
      Nimbus.gdrive_initialized = true;
      if (Nimbus.loaded) {
        if (location.protocol === "chrome-extension:") {
          return this.oauth2_authorize_second_half();
        } else {
          if (Nimbus.Client.GDrive.is_auth_redirected()) {
            Nimbus.Client.GDrive.handle_auth_redirected();
          }
          console.log("GDrive loaded");

          /* 
            @todo check if token has expired
           */
          if (localStorage['phonegap_token']) {
            gapi.auth.setToken(JSON.parse(localStorage['phonegap_token']));
            return _this.prepare_gdrive();
          }
          return gapi.auth.authorize({
            client_id: this.key,
            scope: this.scope,
            immediate: true,
            authuser: localStorage.authuser || 0
          }, (function(_this) {
            return function(data) {
              log("client load handled GDrive");
              log(data);
              if (data !== null && !data.error) {
                return _this.prepare_gdrive();
              }
            };
          })(this));
        }
      }
    },
    gdrive_authorized: function() {
      return Nimbus.Client.GDrive.check_auth();
    },
    logout_gdrive: function(callback) {
      var k, v, _ref;
      localStorage.clear();
      gapi.auth.setToken(null);
      if (Nimbus.dictModel != null) {
        _ref = Nimbus.dictModel;
        for (k in _ref) {
          v = _ref[k];
          v.records = {};
        }
      }
      if (this.sync_services != null) {
        Nimbus.Auth.setup(this.sync_services);
      }
      if (callback != null) {
        return callback();
      }
    },
    prepare_gdrive: function() {
      window.binary_ready_callback = function() {
        if (Nimbus.Auth.authorized_callback != null) {
          return Nimbus.Auth.authorized_callback();
        }
      };
      return Nimbus.realtime.startRealtime(function() {
        log("CURRENT SYNCING CALLBACK");
        Nimbus.Auth.app_ready_func();
        Nimbus.track.google.registered_user();
        return setInterval(function() {
          var is_token_expired, is_token_there;
          is_token_there = (gapi.auth.getToken() != null) && (gapi.auth.getToken().access_token == null);
          if (gapi.auth.getToken()) {
            is_token_expired = gapi.auth.getToken().expires_at - (new Date()).getTime() / 1000 < 60 * 10;
          } else {
            is_token_expired = true;
          }
          if (is_token_there || is_token_expired) {
            return gapi.auth.authorize({
              client_id: Nimbus.Auth.key,
              scope: Nimbus.Auth.scope,
              immediate: true,
              authuser: localStorage.authuser || 0
            }, function(data) {
              return console.log('token refreshed');
            });
          }
          return null;
        }, 60000);
      });

      /*
      Nimbus.current_syncing = new DelayedOp =>
        log("CURRENT SYNCING CALLBACK")
        Nimbus.Auth.app_ready_func()
       */
    },
    oauth2_authorize: function() {
      var background, params, url;
      background = chrome.extension.getBackgroundPage();
      background.NimbusAuth2 = (function(background_window) {
        var NimbusAuth2;
        NimbusAuth2 = {
          OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
          getExtensionId: function() {
            return background_window.chrome.i18n.getMessage("@@extension_id");
          },
          isOauth2AuthorizeRedirected: function(base, state) {
            if (base === this.OAUTH2_REDIRECT_URI && state === this.getExtensionId()) {
              return true;
            }
            return false;
          },
          parseParamsString: function(queryString) {
            var m, params, regex;
            params = {};
            regex = /([^&=]+)=([^&]*)/g;
            while (m = regex.exec(queryString)) {
              params[background_window.decodeURIComponent(m[1])] = background_window.decodeURIComponent(m[2]);
            }
            return params;
          },
          parseRedirectedURL: function(url) {
            var base_url, hash, params, _ref;
            _ref = url.split('#'), base_url = _ref[0], hash = _ref[1];
            params = this.parseParamsString(hash);
            return {
              base_url: base_url,
              params: params
            };
          },
          generateRedirectListener: function() {
            var listener;
            listener = (function(_this) {
              return function(tab_id, change_info, tab) {
                var entension_windows, url_obj, w, _i, _len;
                if (change_info.status !== 'loading') {
                  return;
                }
                url_obj = _this.parseRedirectedURL(tab.url);
                if (_this.isOauth2AuthorizeRedirected(url_obj.base_url, url_obj.params.state)) {
                  background_window.chrome.tabs.onUpdated.removeListener(listener);
                  background_window.chrome.tabs.remove(tab_id);
                  url_obj['saved_time'] = (new background_window.Date()).getTime();
                  background_window.localStorage['_nimbusGDriveAuthObj'] = background_window.JSON.stringify(url_obj);
                  if (_this.isPackagedApp()) {
                    background_window.console.log("in packaged app");
                    entension_windows = background_window.chrome.extension.getViews({
                      type: 'tab'
                    });
                    for (_i = 0, _len = entension_windows.length; _i < _len; _i++) {
                      w = entension_windows[_i];
                      if (w.Nimbus.Auth.GDrive.oauth_status_flag === 'ongoing') {
                        w.Nimbus.Auth.GDrive.oauth2_authorize_second_half();
                      }
                    }
                  } else if (_this.isBrowserAction()) {
                    background_window.console.log("in browser action");
                  }
                  return null;
                }
              };
            })(this);
            return listener;
          },
          installRedirectedListener: function() {
            return background_window.chrome.tabs.onUpdated.addListener(this.generateRedirectListener());
          },
          isBrowserAction: function() {
            return 'browser_action' in background_window.chrome.runtime.getManifest();
          },
          isPackagedApp: function() {
            return 'app' in background_window.chrome.runtime.getManifest();
          }
        };
        return NimbusAuth2;
      })(background);
      Nimbus.Auth.GDrive.oauth_status_flag = 'ongoing';
      background.NimbusAuth2.installRedirectedListener();
      url = "https://accounts.google.com/o/oauth2/auth?";
      params = {
        client_id: this.key,
        scope: this.scope,
        redirect_uri: this.OAUTH2_REDIRECT_URI,
        state: this.getExtensionId(),
        response_type: 'token',
        approval_prompt: 'auto'
      };
      url += this.buildParamsString(params);
      return chrome.tabs.create({
        url: url
      });
    },
    oauth2_authorize_second_half: function() {
      var issued_at, save_token, token, url_obj;
      if (localStorage._nimbusGDriveAuthObj != null) {
        url_obj = JSON.parse(localStorage['_nimbusGDriveAuthObj']);
        if ('error' in url_obj) {
          throw new Error("authorization failed with error: " + url_obj.error);
        }
        save_token = url_obj.params;
        issued_at = Math.round(url_obj.saved_time / 1000);
        save_token.client_id = this.key;
        save_token.scope = this.scope;
        save_token.response_type = 'token';
        save_token.issued_at = issued_at.toString();
        save_token.expires_at = (issued_at + parseInt(save_token.expires_in)).toString();
        save_token.state = '';
        delete localStorage['_nimbusGDriveAuthObj'];
        localStorage['_chromeExtensionAuth2Token'] = JSON.stringify(save_token);
      }
      if (localStorage['_chromeExtensionAuth2Token']) {
        token = JSON.parse(localStorage['_chromeExtensionAuth2Token']);
        gapi.auth.setToken(token);
        Nimbus.Auth.GDrive.oauth_status_flag = 'finish';
        return this.prepare_gdrive();
      }
    },
    OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
    getExtensionId: function() {
      return chrome.i18n.getMessage("@@extension_id");
    },
    buildParamsString: function(obj) {
      var k, params_arr, v;
      params_arr = (function() {
        var _results;
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })();
      return params_arr.join("&");
    },
    getLocalOauth2Token: function(token) {
      if (Nimbus.Auth.GDrive._cacheToken != null) {
        return Nimbus.Auth.GDrive._cacheToken;
      }
      if (localStorage._chromeExtensionAuth2Token != null) {
        token = JSON.parse(localStorage._chromeExtensionAuth2Token);
        Nimbus.Auth.GDrive._cacheToken = token;
        return token;
      } else {
        return null;
      }
    },
    isTokenExpires: function(token) {
      var expires_at, now;
      if ((token != null ? token.expires_at : void 0) != null) {
        expires_at = parseInt(token.expires_at);
        now = (new Date()).getTime();
        if ((expires_at * 1000) > now) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    }
  };

  Nimbus.Model.Firebase = (function() {
    var base, realtimeEvents, root, server, workspaceId;
    base = {};
    root = null;
    server = null;
    realtimeEvents = [];
    workspaceId = '';

    /*
      1. try get firebase workspace root
      2. set server as the pool node for workspace
      3. should be called again when the workspace is changed
     */
    base._setup = function() {
      root = Nimbus.Firebase.server;
      if (workspaceId) {
        return server = root.child(workspaceId + '/pool');
      } else {
        return server = root;
      }
    };
    base.set_workspace = function(id) {
      var workspacePool;
      workspaceId = id;
      if (root) {
        workspacePool = id + '/pool';
        return server = root.child(workspacePool);
      }
    };

    /*
      * firebase uses json ojbect
      currently only return the original object
     */
    base.toCloudStructure = function(data) {
      return JSON.parse(JSON.stringify(data));
    };

    /*
      currently only return the original object
     */
    base.fromCloudStructure = function(data) {
      return JSON.parse(JSON.stringify(data));
    };
    base.diff_objects = function(previous, current) {};

    /*
        basic sync_all implementation
     */
    base.sync_all = function(callback) {
      var _handle;
      _handle = function() {
        this.sync_model_base_algo();
        if (callback) {
          return callback();
        }
      };
      return this.load_all_from_cloud(_handle.bind(this));
    };

    /*
      1. using once to get all value
      2. add value change event for futher uses
     */
    base.load_all_from_cloud = function(complete) {
      var name, _handle;
      name = this.name;
      _handle = function(data) {
        var id, item, objects;
        this.cloudcache = {};
        objects = data.exportVal();
        for (id in objects) {
          item = objects[id];
          if (item.type === name) {
            this.cloudcache[id] = item;
          }
        }
        if (complete) {
          return complete();
        }
      };
      server.once('value', _handle.bind(this));
    };

    /*
      1. trigger localsync model to save to localstorage
     */
    base.add_from_cloud = function(id, callback) {
      var obj, x;
      obj = this.cloudcache[id];
      x = this.init(obj);
      x.synced = true;
      return x.save();
    };

    /*
      1. try update the local data using update method
     */
    base.update_to_local = function(object, callback) {
      var data, x;
      data = this.fromCloudStructure(object);
      data.synced = true;
      x = this.find(data.id);
      if (x) {
        return x.updateAttributes(data);
      }
    };

    /*
      1. this is almost the same for update to cloud
      local is the same
     */
    base.add_to_cloud = function(object, callback) {
      var data, id;
      object.time = new Date().toString();
      object.type = this.name;
      object.synced = true;
      object.save();
      data = this.toCloudStructure(object);
      id = data.id;
      return server.child(id).set(data);
    };
    base.update_to_cloud = function(object, callback) {
      var data, id;
      id = object.id;
      data = this.toCloudStructure(object);
      return server.child(id).set(data);
    };

    /*
      1. remove data on the cloud
     */
    base.delete_from_cloud = function(id, callback) {
      return server.child(id).remove();
    };

    /*
      1. process call chain
     */
    base.process_call_chain = function(mod, obj, isLocal) {
      var event, index, _ref;
      _ref = realtimeEvents[this.name];
      for (index in _ref) {
        event = _ref[index];
        event.apply(this, [mod, obj, isLocal]);
      }
    };

    /*
    
      1. this is quite different from realtime
      we need to observe from the start for every key
     */
    base.onUpdate = function(callback) {
      realtimeEvents = Nimbus.Firebase.realtimeEvents;
      if (!realtimeEvents[this.name]) {
        realtimeEvents[this.name] = [];
      }
      return realtimeEvents[this.name].push(callback);
    };

    /*
      extend method when firebase is initialized
     */
    base.extended = function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    };
    return base;
  })();

  Nimbus.Auth.Firebase = (function() {
    var authObserved, authOject, currentWorkspace, obj, obj_to_array, server;
    obj = {};
    authOject = null;
    server = null;
    authObserved = false;
    currentWorkspace = '';

    /*
      1. create array from a dictionary object
     */
    obj_to_array = function(obj) {
      var item, key, res;
      res = [];
      for (key in obj) {
        item = obj[key];
        item.id = key;
        res.push(item);
      }
      return res;
    };

    /*
      1. set the server
     */
    obj.setServer = function() {
      var getCollaborators;
      server = Nimbus.Firebase.server;

      /*
           1.will check if server is online or offline - todo
       */
      getCollaborators = function(callback) {
        var login;
        login = server.getAuth();
        return server.child(currentWorkspace + '/live').once('value', function(users) {
          var data, index, user;
          data = users.val();
          for (index in data) {
            user = data[index];
            if (user.uid === login.uid) {
              data[index].isMe = true;
            }
          }
          if (callback) {
            return callback(data);
          }
        });
      };
      return Nimbus.realtime.getCollaborators = getCollaborators;
    };

    /*
      1. monitor data in workspace
     */
    obj.watch_workspace = function(id) {
      var apply_to_model, event, isLocal, realtimeEvents;
      apply_to_model = function(event, res, isLocal) {
        var model;
        model = Nimbus.dictModel[obj.type];
        if (model) {
          return model.process_call_chain(event, obj, isLocal);
        }
      };
      realtimeEvents = Nimbus.Firebase.realtimeEvents;
      event = '';
      isLocal = true;
      server.child("" + id + "/pool").on('child_added', function(res) {
        var model;
        event = 'CREATE';
        obj = res.val();
        model = Nimbus.dictModel[obj.type];
        if (!model) {
          return;
        }
        model.cloudcache[obj.id] = obj;
        model.add_from_cloud(obj.id);
        return apply_to_model(event, obj, isLocal);
      });
      server.child("" + id + "/pool").on('child_changed', function(res) {
        var model;
        event = 'UPDATE';
        obj = res.val();
        model = Nimbus.dictModel[obj.type];
        if (!model) {
          return;
        }
        model.update_to_local(obj);
        return apply_to_model(event, res, isLocal);
      });
      server.child("" + id + "/pool").on('child_removed', function(res) {
        var model;
        event = 'DELETE';
        obj = res.val();
        model = Nimbus.dictModel[obj.type];
        delete model.records[obj.id];
        return apply_to_model(event, res, isLocal);
      });
      return server.child("" + id + "/pool").on('value', function(res) {
        if (!res) {
          return console.log('initial create');
        }
      });
    };

    /*
      1. bind the workspace for model
      2. set user in new workspace alive
      3. remove the user in the old workspace
     */
    obj.bind_workspace = function(id) {
      var login;
      login = server.getAuth();
      if (id !== currentWorkspace && currentWorkspace) {
        server.child(currentWorkspace + '/live').transctions(function(data) {
          var index, user;
          for (index in data) {
            user = data[index];
            if (user.uid === login) {
              data.splice(index);
              break;
            }
          }
          return data;
        });
      }
      currentWorkspace = id;
      Nimbus.Model.Firebase.set_workspace(id);
      return server.child(id + '/live').transaction(function(data) {
        var index, live, user;
        data = data ? data : [];
        live = false;
        for (index in data) {
          user = data[index];
          if (user.uid === login.uid) {
            live = true;
            break;
          }
        }
        if (!live) {
          data.push(login);
        }
        return data;
      });
    };

    /*
      1. initialize the workspace if authorization is 
      fullfilled.
     */
    obj.init_workspace = function(callback) {
      var self, user;
      self = this;
      user = server.getAuth();
      server.child('workspaces').once('value', function(res) {
        var data, item, path, workspace, workspaces;
        workspace = '';
        workspaces = [];
        data = res.val();
        if (!data) {
          workspace = item = {
            title: Nimbus.Auth.app_name,
            users: [user.uid],
            owner: user.uid
          };
          path = server.child('workspaces').push(item);
          localStorage['last_opened_workspace'] = path.name();
          workspace.id = path.name();
          workspaces.push(workspace);
        } else {
          workspaces = obj_to_array(data);
          workspace = workspaces[0];
          localStorage['last_opened_workspace'] = workspace.id;
        }
        Nimbus.realtime.c_file = workspace;
        Nimbus.realtime.app_files = workspaces;
        self.watch_workspace(workspace.id);
        self.bind_workspace(workspace.id);
        if (callback) {
          return callback();
        }
      });
      localStorage['state'] = 'Working';

      /*
          a. monitoring workspace changes and save to app_files
       */
      return server.child('workspaces').on('value', function(res) {
        return Nimbus.realtime.app_files = obj_to_array(res.val());
      });
    };

    /*
      1. primary authentication method for firebase
     */
    obj.authenticate_firebase = function(p, d) {
      var auth, authHandler, data, provider, self;
      self = this;
      provider = p ? p : Nimbus.Auth.setting.provider;
      data = d ? d : Nimbus.Auth.setting;
      authHandler = function(err, authData) {
        if (authData) {
          self.init_workspace(function() {
            self.auth_callback(authData);
            Nimbus.Auth.app_ready = true;
            return Nimbus.Auth.app_ready_func();
          });
        } else if (err) {
          console.log(err);
          self.auth_callback(authData);
        }
      };
      auth = {
        'email': data.email,
        'password': data.password
      };
      server.authWithPassword(auth, authHandler);
      return;
      server.authWithCustomToken("<token>", authHandler);
      server.authAnonymously(authHandler);
      server.authWithOAuthPopup("<provider>", authHandler);
      return server.authWithOAuthRedirect("<provider>", authHandler);
    };

    /*
      1. init firebase 
      2. the app ready func should be called before the auth is done?
     */
    obj.initialize_firebase = function() {
      var self;
      server = Nimbus.Firebase.server;
      self = this;
      if (!authObserved) {
        server.onAuth(function(authData) {
          if (authData) {
            console.log('success', authData);
            return self.init_workspace(function() {
              self.auth_callback(authData);
              Nimbus.Auth.app_ready = true;
              return Nimbus.Auth.app_ready_func();
            });
          } else {
            console.log('failed');
            return self.auth_callback(authData);
          }
        });
        authObserved = true;
      }
    };

    /*
      1. check if the user is authorized
     */
    obj.firebase_authorized = function() {
      var authData;
      authData = server.getAuth();
      return authData;
    };

    /*
      1. sign out the current user
     */
    obj.logout = function() {
      localStorage.clear();
      return server.unauth();
    };
    obj.auth_changed = function(cb) {
      return console.log('push cd in watch stack');
    };
    obj.auth_callback = function() {
      return console.log('placeholder callback for auth');
    };
    return obj;
  })();

  Nimbus.Client.Firebase = (function() {
    var client, register_user, server;
    server = {};
    client = {};
    client._setup = function() {
      return server = Nimbus.Firebase.server;
    };

    /*
      1. switch workspace
     */
    client.switch_to_app_file_real = function(id, callback) {
      var node;
      node = "workspaces/" + id;
      return server.child(node).once("value", function(res) {
        var k, v, _ref;
        Nimbus.realtime.c_file = res.val();
        Nimbus.realtime.c_file.id = id;
        if (Nimbus.dictModel != null) {
          _ref = Nimbus.dictModel;
          for (k in _ref) {
            v = _ref[k];
            v.records = {};
            v.cloudcache = {};
            delete localStorage[v.name];
          }
        }
        Nimbus.Model.Firebase.set_workspace(id);
        if (callback) {
          return callback();
        }
      });
    };

    /*
      Register user and send email
     */
    register_user = function(email, callback) {
      return server.createUser({
        'email': email,
        password: 'freethecloud'
      }, function(data) {
        if (callback) {
          return callback(data);
        }
      });
    };

    /*
      send email with the password - todo
     */

    /*
      1. add share user
      2. register with this email - todo
     */
    client.add_share_user_real = function(email, callback) {
      var allows, item, node, workspace;
      workspace = Nimbus.realtime.c_file;
      node = "workspaces/" + workspace.id + "/users/";
      allows = "workspaces/" + workspace.id + "/allows/";
      item = {
        pid: email,
        id: email,
        "email": email,
        "name": email,
        permissionId: email
      };
      server.child(node).transaction(function(data) {
        var index, insert, user;
        insert = true;
        for (index in data) {
          user = data[index];
          if (user.email === email) {
            insert = false;
            break;
          }
        }
        if (insert) {
          data.push(item);
        }
        if (callback) {
          callback(item);
        }
        return data;
      });
      return server.child(allows).transaction(function(data) {
        var index, val;
        if (!data) {
          data = [];
        } else {
          for (index in data) {
            val = data[index];
            if (val === email) {
              return data;
            }
          }
        }
        data[data.length] = email;
        return data;
      });
    };

    /*
      1.
     */
    client.remove_share_user_real = function(email, callback) {
      var node, workspace;
      workspace = Nimbus.realtime.c_file;
      node = "workspaces/" + workspace.id + "/users/";
      return server.child(node).transaction(function(data) {
        var index, user;
        for (index in data) {
          user = data[index];
          if (user.email === email) {
            data.splice(index);
          }
        }
        if (callback) {
          callback();
        }
        return data;
      });
    };

    /*
      1. get_user_email for password login
     */
    client.get_user_email = function() {
      var user;
      user = server.getAuth();
      return server.password.email;
    };

    /*
      1. return the constructed user object for share
     */
    client.get_current_user = function(callback) {
      var me, user;
      user = server.getAuth();
      me = {
        email: user.password.email,
        pic: '',
        displayName: user.uid,
        permissionId: user.uid,
        id: user.uid
      };
      if (callback) {
        return callback(me);
      }
    };

    /*
      1. get_shared_users return user list in workspaces/workspaceId/users
     */
    client.get_shared_users_real = function(callback) {
      var node, workspace;
      workspace = Nimbus.realtime.c_file;
      node = "workspaces/" + workspace.id + "/users";
      return server.child(node).once('value', function(res) {
        var data;
        data = res.val();
        if (!data) {
          data = [];
        }
        if (callback) {
          return callback(data);
        }
      });
    };

    /*
      1. create a workspace - todo
     */
    client.create_workspace = function(title, callback) {
      var email, id, owner, path, user, workspace;
      user = server.getAuth();
      email = user.password.email;
      owner = {
        role: 'Owner',
        id: user.uid,
        permissionId: user.uid,
        pic: '',
        displayName: user.uid,
        name: email,
        'email': email
      };
      workspace = {
        'title': title,
        'users': [owner],
        'owners': [owner],
        'mimeType': 'workspace'
      };
      path = server.child('workspaces').push(workspace);
      id = path.name();
      server.child(id + '/users').transaction(function(data) {
        if (!data) {
          data = [];
        }
        return data.push(owner);
      });
      if (callback) {
        return callback(workspace);
      }
    };

    /*
      1. delete workspace itself
         delete workspace pool data
     */
    client.deleteFile = function(id, callback) {
      var file, index, _ref, _results;
      server.child(id).remove();
      server.child('workspaces/' + id).remove();
      _ref = Nimbus.realtime.app_files;
      _results = [];
      for (index in _ref) {
        file = _ref[index];
        if (file.id === id) {
          _results.push(Nimbus.realtime.app_files.splice(index));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    return client;
  })();

  Nimbus.Auth.Multi = {
    authenticate_service: function(service) {
      var key, user_email_scope, val, x, _ref;
      log("authenticate a single service", service);
      isArray = Array.isArray || function(value) {
        return {}.toString.call(value) === '[object Array]';
      };
      if ((this.sync_services != null) && (this.sync_services[service] != null)) {
        x = this.sync_services[service];
        x["service"] = service;
        if (service === "Dropbox") {
          Nimbus.Auth.setup(x);
        }
        if (service === "GDrive") {
          user_email_scope = 'https://www.googleapis.com/auth/userinfo.email';
          if (isArray(x.scope)) {
            if (__indexOf.call(x.scope, user_email_scope) < 0) {
              x.scope.push(user_email_scope);
            }
          } else {
            x.scope = [x.scope, user_email_scope];
          }
          if (x.scope.indexOf('openid') === -1) {
            x.scope.push('openid');
          }
          x.scope = x.scope.join(" ");
          if (x.client_secret != null) {
            Nimbus.Auth.setup(x);
          } else {
            Nimbus.Auth.setup(x);
          }
        } else if (service === 'Firebase') {
          Nimbus.Auth.setup(x);
          Nimbus.Auth.setting = arguments[1];
        }
        _ref = Nimbus.dictModel;
        for (key in _ref) {
          val = _ref[key];
          Nimbus.Model.service_setup(val);
        }
        Nimbus.Auth.initialize();
        return Nimbus.Auth.authorize();
      }
    },
    initialize_service: function() {
      log("initializing service");
      return Nimbus.Auth.reinitialize();
    }
  };

  Nimbus.Auth.reinitialize();

  Nimbus.backbone_store = function(name, model) {
    var k, k_arr, m, nimbus_model, store, v, _ref;
    log("Model on creation", model);
    this.name = name;
    m = new model;
    k_arr = [];
    _ref = m.attributes;
    for (k in _ref) {
      v = _ref[k];
      k_arr.push(k);
    }
    nimbus_model = Nimbus.Model.setup(name, k_arr);
    store = nimbus_model;
    this.data = (nimbus_model.all()) || {};
    return store;
  };

  Nimbus.backbone_sync = function(method, model, options) {
    var a, resp, s, store;
    resp = void 0;
    store = model.nimbus || model.collection.nimbus;
    window.model = model;
    switch (method) {
      case "read":
        if (model.id) {
          resp = store.find(model);
        } else {
          store.sync_all(function() {
            resp = store.all();
            return options.success(resp);
          });
          return;
        }
        break;
      case "create":
        console.log("create called");
        a = store.init(model.attributes);
        a.id = model.id;
        a.save();
        resp = a;
        break;
      case "update":
        s = store.find(model.id);
        s.updateAttributes(model.attributes);
        s.save();
        resp = s;
        break;
      case "delete":
        console.log("deletion find", store.find(model.id));
        resp = store.find(model.id).destroy();
    }
    if (resp) {
      return options.success(resp);
    } else {
      return options.error("Record not found");
    }
  };

  Nimbus.angularService = function() {
    var all_models, makeWatcher, setup;
    all_models = {};
    setup = function(name, attrs, sync_callback) {
      var store;
      store = Nimbus.Model.setup(name, attrs);
      store.sync_all(sync_callback);
      all_models['name'] = store;
      return store;
    };
    makeWatcher = function(name) {
      return function() {
        return localStorage[name];
      };
    };
    return {
      'setup': setup,
      'makeWatcher': makeWatcher
    };
  };

  mixpanel_token = "57da9d172e8c2000bca77d9ebb935752";

  Nimbus.track = {
    send_people_request: function(x) {
      var encoded, xhr;
      xhr = new XMLHttpRequest();
      log(JSON.stringify(x));
      encoded = Base64.encode(JSON.stringify(x));
      xhr.open("POST", "http://api.mixpanel.com/engage");
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = (function(_this) {
        return function(status, response) {
          if (xhr.readyState === 4) {
            try {
              log("xhr", xhr);
              log("mixpanel response done");
              return log("response: ", xhr.response);
            } catch (_error) {}
          }
        };
      })(this);
      xhr.send(data);
      return xhr;
    },
    registered_user: function() {
      var email;
      log("registered user");
      if (Nimbus.Auth.service === "Dropbox") {
        Nimbus.Client.Dropbox.getAccountInfo(function(info) {
          var email, first, last, n, x, _ref;
          n = info.display_name;
          _ref = n.split(" "), first = _ref[0], last = _ref[1];
          email = "";
          if (info.email != null) {
            email = info.email;
          }
          x = {
            $set: {
              $first_name: first,
              $last_name: last,
              $app: Nimbus.Auth.app_name,
              $service: Nimbus.Auth.service,
              $email: email,
              $url: window.location.href
            },
            $token: mixpanel_token,
            $distinct_id: email
          };
          log(x);
          return Nimbus.track.send_people_request(x);
        });
      }
      if (Nimbus.Auth.service === "GDrive") {
        email = Nimbus.Client.GDrive.get_user_email();
        return Nimbus.Client.GDrive.get_current_user(function(info) {
          var first, last, n, x, _ref;
          n = info.name;
          _ref = n.split(" "), first = _ref[0], last = _ref[1];
          x = {
            $set: {
              $first_name: first,
              $last_name: last,
              $app: Nimbus.Auth.app_name,
              $service: Nimbus.Auth.service,
              $email: email,
              $url: window.location.href
            },
            $token: mixpanel_token,
            $distinct_id: email
          };
          log(x);
          return Nimbus.track.send_people_request(x);
        });
      }
    },
    report_storage_stat: function() {
      var last_reported_date, now;
      log("report storage stat");
      now = new Date();
      if (localStorage["last_reported_date"] != null) {
        last_reported_date = localStorage["last_reported_date"];
      }
      if (last_reported_date) {
        if (now - last_reported_date > 86400000) {
          log("start sending data");
        }
        return localStorage["last_reported_date"] = now;
      } else {
        return log("start sending data");
      }
    }
  };

  this.Nimbus = Nimbus;

  baseUrl = "http://www.google-analytics.com/collect?v=1&tid=UA-46950334-1&cid=001";

  Nimbus.track.google = {
    data: {
      page_url: "",
      app_name: "",
      cloudType: "",
      email: ""
    },
    send_page_tracking: function(url) {
      var path, xhr;
      path = baseUrl + "&t=pageview&dp=" + encodeURI(url);
      xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      xhr.send(null);
    },
    send_event_tracking: function(dom, action, id, value) {
      var path, xhr;
      if (dom == null) {
        dom = 0;
      }
      if (action == null) {
        action = 0;
      }
      if (id == null) {
        id = 0;
      }
      if (value == null) {
        value = 0;
      }
      path = baseUrl + "&t=event&ec=" + encodeURI(dom) + "&ea=" + encodeURI(action) + "&ev=" + encodeURI(value) + "&el=" + encodeURI(id);
      xhr = new XMLHttpRequest();
      xhr.open("GET", path, true);
      return xhr.send(null);
    },
    registered_user: function() {
      this.data["page_url"] = window.location.href;
      this.data["app_name"] = Nimbus.Auth.app_name;
      this.data["cloudType"] = Nimbus.Auth.service;
      this.send_page_tracking(this.data.page_url);
      setTimeout(function() {
        var count, data, i, len;
        count = 0;
        for (i in Nimbus.dictModel) {
          len = Nimbus.dictModel[i].all().length;
          count = count + len;
        }
        Nimbus.track.google.data["sum"] = count;
        data = Nimbus.track.google.data;
        log("send to gogole analytic :", data);
        Nimbus.track.google.send_event_tracking(data.app_name, data.email, data.cloudType, data.sum);
      }, 15000);
      if (Nimbus.Auth.service === "Dropbox") {
        Nimbus.Client.Dropbox.getAccountInfo(function(info) {
          if (info.email != null) {
            return Nimbus.track.google.data["email"] = info.email;
          }
        });
      }
      if (Nimbus.Auth.service === "GDrive") {
        return Nimbus.track.google.data["email"] = Nimbus.Client.GDrive.get_user_email();
      }
    }
  };

  window.onerror = function(msg, url, line) {
    var error, info;
    error = {
      email: Nimbus.track.google.data.email,
      app_name: Nimbus.track.google.data.app_name,
      cloudType: Nimbus.track.google.data.cloudType,
      line_: line,
      url_: url,
      msg_: msg
    };
    info = JSON.stringify(error);
    info = info.replace(/"/g, "").replace(/{/g, "").replace(/}/g, "");
    info = encodeURI(info);
    info = info.replace(/%20/g, "_").replace(/#/g, "_");
    log("got error, send to  google analytic:", encodeURI(info));
    return Nimbus.track.google.send_event_tracking(error.app_name, "error", encodeURI(info), 400);
  };

}).call(this);
